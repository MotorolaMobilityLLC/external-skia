#!/usr/bin/python

# Copyright 2014 Google Inc.
#
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""
Functions for creating an Android.mk from already created dictionaries.
"""

import os
import variables

def write_group(f, name, items, append):
  """
  Helper function to list all names passed to a variable.
  @param f File open for writing (Android.mk)
  @param name Name of the makefile variable (e.g. LOCAL_CFLAGS)
  @param items list of strings to be passed to the variable.
  @param append Whether to append to the variable or overwrite it.
  """
  if not items:
    return

  # Copy the list so we can prepend it with its name.
  items_to_write = list(items)

  if append:
    items_to_write.insert(0, '%s +=' % name)
  else:
    items_to_write.insert(0, '%s :=' % name)

  f.write(' \\\n\t'.join(items_to_write))

  f.write('\n\n')


def write_local_vars(f, var_dict, append):
  """
  Helper function to write all the members of var_dict to the makefile.
  @param f File open for writing (Android.mk)
  @param var_dict VarsDict holding the unique values for one configuration.
  @param append Whether to append to each makefile variable or overwrite it.
  """
  for key in var_dict.keys():
    if key == 'LOCAL_CFLAGS':
      # Always append LOCAL_CFLAGS. This allows us to define some early on in
      # the makefile and not overwrite them.
      _append = True
    elif key == 'KNOWN_TARGETS':
      # KNOWN_TARGETS are not needed in the final make file.
      continue
    else:
      _append = append
    write_group(f, key, var_dict[key], _append)


AUTOGEN_WARNING = (
"""
###############################################################################
#
# THIS FILE IS AUTOGENERATED BY GYP_TO_ANDROID.PY. DO NOT EDIT.
#
###############################################################################

"""
)


DEBUGGING_HELP = (
"""
###############################################################################
#
# PROBLEMS WITH SKIA DEBUGGING?? READ THIS...
#
# The debug build results in changes to the Skia headers. This means that those
# using libskia must also be built with the debug version of the Skia headers.
# There are a few scenarios where this comes into play:
#
# (1) You're building debug code that depends on libskia.
#   (a) If libskia is built in release, then define SK_RELEASE when building
#       your sources.
#   (b) If libskia is built with debugging (see step 2), then no changes are
#       needed since your sources and libskia have been built with SK_DEBUG.
# (2) You're building libskia in debug mode.
#   (a) RECOMMENDED: You can build the entire system in debug mode. Do this by
#       updating your build/config.mk to include -DSK_DEBUG on the line that
#       defines COMMON_GLOBAL_CFLAGS
#   (b) You can update all the users of libskia to define SK_DEBUG when they are
#       building their sources.
#
# NOTE: If neither SK_DEBUG or SK_RELEASE are defined then Skia checks NDEBUG to
#       determine which build type to use.
###############################################################################

"""
)


# TODO (scroggo): Currently write_android_mk has intimate knowledge about its
# parameters: e.g. arm_neon keeps track of differences from arm, whereas the
# others keep track of differences from common. Consider reworking this.
def write_android_mk(target_dir, common, arm, arm_neon, x86, default):
  """
  Given all the variables, write the final make file.
  @param target_dir The full path to the directory to write Android.mk, or None
                    to use the current working directory.
  @param common VarsDict holding variables definitions common to all
                configurations.
  @param arm VarsDict holding variable definitions unique to arm. Will be
             written to the makefile inside an 'ifeq ($(TARGET_ARCH), arm)'
             block.
  @param arm_neon VarsDict holding variable definitions unique to arm with neon.
                 Will be written inside an 'ifeq ($(ARCH_ARM_HAVE_NEON),true)'
                 block nested inside an 'ifeq ($(TARGET_ARCH), arm)' block.
  @param x86 VarsDict holding variable definitions unique to x86. Will be
             written inside an 'ifeq ($(TARGET_ARCH),x86)' block.
  @param default VarsDict holding variable definitions for an architecture
                 without custom optimizations.
  TODO: Add mips.
  """
  target_file = 'Android.mk'
  if target_dir:
    target_file = os.path.join(target_dir, target_file)
  with open(target_file, 'w') as f:
    f.write(AUTOGEN_WARNING)
    f.write('BASE_PATH := $(call my-dir)\n')
    f.write('LOCAL_PATH:= $(call my-dir)\n')

    f.write(DEBUGGING_HELP)

    f.write('include $(CLEAR_VARS)\n')

    f.write('LOCAL_ARM_MODE := thumb\n')

    # need a flag to tell the C side when we're on devices with large memory
    # budgets (i.e. larger than the low-end devices that initially shipped)
    f.write('ifeq ($(ARCH_ARM_HAVE_VFP),true)\n')
    f.write('\tLOCAL_CFLAGS += -DANDROID_LARGE_MEMORY_DEVICE\n')
    f.write('endif\n\n')

    f.write('ifeq ($(TARGET_ARCH),x86)\n')
    f.write('\tLOCAL_CFLAGS += -DANDROID_LARGE_MEMORY_DEVICE\n')
    f.write('endif\n\n')

    f.write('# used for testing\n')
    f.write('#LOCAL_CFLAGS += -g -O0\n\n')

    f.write('ifeq ($(NO_FALLBACK_FONT),true)\n')
    f.write('\tLOCAL_CFLAGS += -DNO_FALLBACK_FONT\n')
    f.write('endif\n\n')

    write_local_vars(f, common, False)

    f.write('ifeq ($(TARGET_ARCH),arm)\n')
    f.write('ifeq ($(ARCH_ARM_HAVE_NEON),true)\n')
    write_local_vars(f, arm_neon, True)
    f.write('endif\n\n')
    write_local_vars(f, arm, True)

    if variables.INCLUDE_X86_OPTS:
      f.write('else ifeq ($(TARGET_ARCH),x86)\n')
      write_local_vars(f, x86, True)

    f.write('else\n')
    write_local_vars(f, default, True)
    f.write('endif\n\n')

    f.write('include external/stlport/libstlport.mk\n')
    f.write('LOCAL_MODULE:= libskia\n')
    f.write('include $(BUILD_SHARED_LIBRARY)\n')



