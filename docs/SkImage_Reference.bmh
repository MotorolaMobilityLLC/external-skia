#Topic Image
#Alias Image_Reference

#Class SkImage

Image describes a two dimensional array of pixels to draw. The pixels may be
unencoded in a Raster_Bitmap, encoded in a Picture or compressed data stream,
or located in GPU memory as a GPU_Texture.

Image cannot be modified after it is created. Image may allocate additional
storage as needed; for instance, an encoded Image may decode when drawn.

Image width and height are greater than zero. Creating an Image with zero width
or height returns Image equal to nullptr.

Image may be created from Bitmap, Pixmap, Surface, Picture, encoded streams,
GPU_Texture, YUV_ColorSpace data, or hardware buffer. Encoded streams supported
include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP. Supported encodings details
vary with platform.

#Topic Raster_Image
#Alias Raster_Image
Raster_Image pixels are unencoded in a Raster_Bitmap. These pixels may be read
directly and in most cases written to, although edited pixels may not be drawn
if Image has been copied internally.
##

#Topic Texture_Image
Texture_Image are located on GPU and pixels are not accessible. Texture_Image
are allocated optimally for best performance. Raster_Image may
be drawn to GPU_Surface, but pixels are uploaded from CPU to GPU downgrading
performance.
##

#Topic Lazy_Image
Lazy_Image defer allocating buffer for Image pixels and decoding stream until
Image is drawn. Lazy_Image caches result if possible to speed up repeated
drawing.
##

#Topic Overview

#Subtopic Subtopics
#ToDo manually add subtopics ##
#Table
#Legend
# topics # description ##
#Legend ##
#Table ##
##

#Subtopic Member_Functions
#Table
#Legend
# description                      # function ##
#Legend ##
# MakeBackendTextureFromSkImage    # Creates GPU_Texture from Image. ##
# MakeCrossContextFromEncoded      # Creates Image from encoded data, and uploads to GPU. ##
# MakeFromAHardwareBuffer          # Creates Image from Android hardware buffer. ##
# MakeFromAdoptedTexture           # Creates Image from GPU_Texture, managed internally. ##
# MakeFromBitmap                   # Creates Image from Bitmap, sharing or copying pixels. ##
# MakeFromDeferredTextureImageData # ##
# MakeFromEncoded                  # Creates Image from encoded data. ##
# MakeFromGenerator                # Creates Image from a stream of data. ##
# MakeFromNV12TexturesCopy         # Creates Image from YUV_ColorSpace data in two planes. ##
# MakeFromPicture                  # Creates Image from Picture. ##
# MakeFromRaster                   # Creates Image from Pixmap, with release. ##
# MakeFromTexture                  # Creates Image from GPU_Texture, managed externally. ##
# MakeFromYUVTexturesCopy          # Creates Image from YUV_ColorSpace data in three planes. ##
# MakeRasterCopy                   # Creates Image from Pixmap and copied pixels. ##
# MakeRasterData                   # Creates Image from Image_Info and shared pixels. ##
# alphaType                        # Returns Alpha_Type. ##
# asLegacyBitmap                   # Returns as Raster_Bitmap. ##
# bounds()                         # Returns width() and height() as Rectangle. ##
# colorSpace                       # Returns Color_Space. ##
# dimensions()                     # Returns width() and height(). ##
# encodeToData                     # Returns encoded Image as SkData. ##
# getDeferredTextureImageData      # ##
# getTexture                       # Deprecated. ##
# getTextureHandle                 # Returns GPU reference to Image as texture. ##
# height()                         # Returns pixel row count. ##
# isAlphaOnly                      # Returns if pixels represent a transparency mask. ##
# isLazyGenerated                  # Returns if Image is created as needed. ##
# isOpaque                         # Returns if Alpha_Type is kOpaque_SkAlphaType. ##
# isTextureBacked                  # Returns if Image was created from GPU_Texture. ##
# isValid                          # Returns if Image can draw to Raster_Surface or GPU_Context. ##
# makeColorSpace                   # Creates Image matching Color_Space if possible. ##
# makeNonTextureImage              # Creates Image without dependency on GPU_Texture. ##
# makeRasterImage                  # Creates Image compatible with Raster_Surface if possible. ##
# makeShader                       # Creates Shader, Paint element that can tile Image. ##
# makeSubset                       # Creates Image containing part of original. ##
# makeTextureImage                 # Creates Image matching Color_Space if possible. ##
# makeWithFilter                   # Creates filtered, clipped Image. ##
# peekPixels                       # Returns Pixmap if possible. ##
# readPixels                       # Copies and converts pixels. ##
# refColorSpace                    # Returns Image_Info Color_Space. ##
# refEncodedData                   # Returns Image encoded in SkData if present. ##
# scalePixels                      # Scales and converts one Image to another. ##
# toString                         # Converts Image to machine readable form. ##
# uniqueID                         # Identifier for Image. ##
# width()                          # Returns pixel column count. ##
#Table ##
#Subtopic ##

#Topic ##

#Typedef SkImageInfo Info

##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeRasterCopy(const SkPixmap& pixmap)

Creates Image from Pixmap and copy of pixels. Since pixels are copied, Pixmap
pixels may be modified or deleted without affecting Image.

Image is returned if Pixmap is valid. Valid Pixmap parameters include:
dimensions are greater than zero;
each dimension fits in 29 bits;
Color_Type and Alpha_Type are valid, and Color_Type is not kUnknown_SkColorType;
row bytes are large enough to hold one row of pixels;
pixel address is not nullptr.

#Param pixmap  Image_Info, pixel address, and row bytes ##

#Return copy of Pixmap pixels, or nullptr  ##

#Example
#Height 50
#Description
Draw a five by five bitmap, and draw a copy in an Image. Editing the pixmap
alters the bitmap draw, but does not alter the Image draw since the Image
contains a copy of the pixels.
##
    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },
                            { 0xAC, 0xA8, 0x89, 0xA7, 0x87 },
                            { 0x9B, 0xB5, 0xE5, 0x95, 0x46 },
                            { 0x90, 0x81, 0xC5, 0x71, 0x33 },
                            { 0x75, 0x55, 0x44, 0x40, 0x30 }};
    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);
    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);
    *pixmap.writable_addr8(2, 2) = 0x00;
    canvas->scale(10, 10);
    canvas->drawBitmap(bitmap, 0, 0);
    canvas->drawImage(image, 10, 0);
##

#SeeAlso MakeRasterData MakeFromGenerator

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeRasterData(const Info& info, sk_sp<SkData> pixels, size_t rowBytes)

Creates Image from Image_Info, sharing pixels.

Image is returned if Image_Info is valid. Valid Image_Info parameters include:
dimensions are greater than zero;
each dimension fits in 29 bits;
Color_Type and Alpha_Type are valid, and Color_Type is not kUnknown_SkColorType;
rowBytes are large enough to hold one row of pixels;
pixels is not nullptr, and contains enough data for Image.

#Param info  contains width, height, Alpha_Type, Color_Type, Color_Space ##
#Param pixels  address or pixel storage ##
#Param rowBytes  size of pixel row or larger ##

#Return Image sharing pixels, or nullptr ##

#Example
#Image 3
    size_t rowBytes = image->width() * SkColorTypeBytesPerPixel(kRGBA_8888_SkColorType);
    sk_sp<SkData> data = SkData::MakeUninitialized(rowBytes * image->height());
    SkImageInfo dstInfo = SkImageInfo::MakeN32(image->width(), image->height(), 
                                               kPremul_SkAlphaType);
    image->readPixels(dstInfo, data->writable_data(), rowBytes, 0, 0, SkImage::kAllow_CachingHint);
    sk_sp<SkImage> raw = SkImage::MakeRasterData(dstInfo.makeColorType(kRGBA_8888_SkColorType),
                                                 data, rowBytes);
    canvas->drawImage(image, 0, 0);
    canvas->drawImage(raw.get(), 128, 0);
##

#SeeAlso MakeRasterCopy MakeFromGenerator

#Method ##

# ------------------------------------------------------------------------------

#Typedef void* ReleaseContext

Caller data passed to RasterReleaseProc; may be nullptr.

#SeeAlso MakeFromRaster RasterReleaseProc

##

#Typedef void (*RasterReleaseProc)(const void* pixels, ReleaseContext)

Function called when Image no longer shares pixels. ReleaseContext is
provided by caller when Image is created, and may be nullptr.   

#SeeAlso ReleaseContext MakeFromRaster

##

#Method static sk_sp<SkImage> MakeFromRaster(const SkPixmap& pixmap,
                                         RasterReleaseProc rasterReleaseProc,
                                         ReleaseContext releaseContext)

Creates Image from pixmap, sharing Pixmap pixels. Pixels must remain valid and
unchanged until rasterReleaseProc is called. rasterReleaseProc is passed
releaseContext when Image is deleted or no longer refers to pixmap pixels.

Pass nullptr for rasterReleaseProc to share Pixmap without requiring a callback
when Image is released. Pass nullptr for releaseContext if rasterReleaseProc
does not require state.

Image is returned if pixmap is valid. Valid Pixmap parameters include:
dimensions are greater than zero;
each dimension fits in 29 bits;
Color_Type and Alpha_Type are valid, and Color_Type is not kUnknown_SkColorType;
row bytes are large enough to hold one row of pixels;
pixel address is not nullptr.

#Param pixmap  Image_Info, pixel address, and row bytes ##
#Param rasterReleaseProc  function called when pixels can be released; or nullptr ##
#Param releaseContext  state passed to rasterReleaseProc; or nullptr ##

#Return Image sharing pixmap ##

#Example
#Function
static void releaseProc(const void* pixels, SkImage::ReleaseContext context) {
     int* countPtr = static_cast<int*>(context);
     *countPtr += 1;
}
##

void draw(SkCanvas* canvas) {
    SkColor color = 0;
    SkPixmap pixmap(SkImageInfo::MakeN32(1, 1, kPremul_SkAlphaType), &color, 4);
    int releaseCount = 0;
    sk_sp<SkImage> image(SkImage::MakeFromRaster(pixmap, releaseProc, &releaseCount));
    SkDebugf("before reset: %d\n", releaseCount);
    image.reset();
    SkDebugf("after reset: %d\n", releaseCount);
}
#StdOut
before reset: 0
after reset: 1
##
##

#SeeAlso MakeRasterCopy MakeRasterData MakeFromGenerator RasterReleaseProc ReleaseContext

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromBitmap(const SkBitmap& bitmap)

Creates Image from bitmap, sharing or copying bitmap pixels. If the bitmap 
is marked immutable, and its pixel memory is shareable, it may be shared
instead of copied.

Image is returned if bitmap is valid. Valid Bitmap parameters include:
dimensions are greater than zero;
each dimension fits in 29 bits;
Color_Type and Alpha_Type are valid, and Color_Type is not kUnknown_SkColorType;
row bytes are large enough to hold one row of pixels;
pixel address is not nullptr.

#Param bitmap  Image_Info, row bytes, and pixels ##

#Return created Image, or nullptr ##

#Example
#Description
The first Bitmap is shared; writing to the pixel memory changes the first
Image.
The second Bitmap is marked immutable, and is copied; writing to the pixel
memory does not alter the second Image.
##
#Height 50
    uint8_t storage[][5] = {{ 0xCA, 0xDA, 0xCA, 0xC9, 0xA3 },
                            { 0xAC, 0xA8, 0x89, 0xA7, 0x87 },
                            { 0x9B, 0xB5, 0xE5, 0x95, 0x46 },
                            { 0x90, 0x81, 0xC5, 0x71, 0x33 },
                            { 0x75, 0x55, 0x44, 0x40, 0x30 }};
    SkImageInfo imageInfo = SkImageInfo::Make(5, 5, kGray_8_SkColorType, kOpaque_SkAlphaType);
    SkPixmap pixmap(imageInfo, storage[0], sizeof(storage) / 5);
    SkBitmap bitmap;
    bitmap.installPixels(pixmap);
    sk_sp<SkImage> image1 = SkImage::MakeFromBitmap(bitmap);
    bitmap.setImmutable();
    sk_sp<SkImage> image2 = SkImage::MakeFromBitmap(bitmap);
    *pixmap.writable_addr8(2, 2) = 0x00;
    canvas->scale(10, 10);
    canvas->drawImage(image1, 0, 0);
    canvas->drawImage(image2, 10, 0);
##

#SeeAlso MakeFromRaster MakeRasterCopy MakeFromGenerator MakeRasterData

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromGenerator(std::unique_ptr<SkImageGenerator> imageGenerator,
                                            const SkIRect* subset = nullptr)

Creates Image from data returned by imageGenerator. Generated data is owned by Image and may not
be shared or accessed.

subset allows selecting a portion of the full image. Pass nullptr to select the entire image;
otherwise, subset must be contained by image bounds.

Image is returned if generator data is valid. Valid data parameters vary by type of data
and platform.

imageGenerator may wrap Picture data, codec data, or custom data.

#Param imageGenerator  stock or custom routines to retrieve Image ##
#Param subset  bounds of returned Image; may be nullptr ##

#Return created Image, or nullptr ##

#Example
#Description
The generator returning Picture cannot be shared; std::move transfers ownership to generated Image.
##
    SkPictureRecorder recorder;
    recorder.beginRecording(100, 100)->drawColor(SK_ColorRED);
    auto picture = recorder.finishRecordingAsPicture();
    auto gen = SkImageGenerator::MakeFromPicture({100, 100}, picture, nullptr, nullptr,
                                                 SkImage::BitDepth::kU8, SkColorSpace::MakeSRGB());
    sk_sp<SkImage> image = SkImage::MakeFromGenerator(std::move(gen));
    canvas->drawImage(image, 0, 0);
##

#SeeAlso MakeFromEncoded

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromEncoded(sk_sp<SkData> encoded, const SkIRect* subset = nullptr)

Creates Image from encoded data. 
subset allows selecting a portion of the full image. Pass nullptr to select the entire image;
otherwise, subset must be contained by image bounds.

Image is returned if format of the encoded data is recognized and supported.
Recognized formats vary by platfrom.

#Param encoded  data of Image to decode ##
#Param subset  bounds of returned Image; may be nullptr ##

#Return created Image, or nullptr ##

#Example
#Image 3
int x = 0;
for (int quality : { 100, 50, 10, 1} ) {
    sk_sp<SkData> encodedData = image->encodeToData(SkEncodedImageFormat::kJPEG, quality);
    sk_sp<SkImage> image = SkImage::MakeFromEncoded(encodedData);
    canvas->drawImage(image, x, 0);
    x += 64;
}
##

#SeeAlso MakeFromGenerator

#Method ##

# ------------------------------------------------------------------------------

#Typedef void (*TextureReleaseProc)(ReleaseContext releaseContext)

##

#Method static sk_sp<SkImage> MakeFromTexture(GrContext* context,
                                          const GrBackendTexture& backendTexture,
                                          GrSurfaceOrigin origin,
                                          SkAlphaType alphaType,
                                          sk_sp<SkColorSpace> colorSpace)

Deprecated.

#Param context  GPU_Context ##
#Param backendTexture  texture residing on GPU ##
#Param origin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param alphaType  one of: kUnknown_SkAlphaType, kOpaque_SkAlphaType,
                          kPremul_SkAlphaType, kUnpremul_SkAlphaType
##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

#NoExample
##

#SeeAlso MakeFromAdoptedTexture SkSurface::MakeFromBackendTexture

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromTexture(GrContext* context,
                                          const GrBackendTexture& backendTexture,
                                          GrSurfaceOrigin origin,
                                          SkAlphaType alphaType,
                                          sk_sp<SkColorSpace> colorSpace,
                                          TextureReleaseProc textureReleaseProc,
                                          ReleaseContext releaseContext)

Deprecated.

#Param context  GPU_Context ##
#Param backendTexture  texture residing on GPU ##
#Param origin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param alphaType  one of: kUnknown_SkAlphaType, kOpaque_SkAlphaType,
                          kPremul_SkAlphaType, kUnpremul_SkAlphaType
##
#Param colorSpace  range of colors; may be nullptr ##
#Param textureReleaseProc  function called when texture can be released ##
#Param releaseContext  state passed to textureReleaseProc ##

#Return created Image, or nullptr ##

#NoExample
##

#SeeAlso MakeFromAdoptedTexture SkSurface::MakeFromBackendTexture

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromTexture(GrContext* context,
                                          const GrBackendTexture& backendTexture,
                                          GrSurfaceOrigin origin,
                                          SkColorType colorType,
                                          SkAlphaType alphaType,
                                          sk_sp<SkColorSpace> colorSpace)

Creates Image from GPU_Texture associated with context. Caller is responsible for
managing the lifetime of GPU_Texture.

Image is returned if format of backendTexture is recognized and supported.
Recognized formats vary by GPU back-end.

#Param context  GPU_Context ##
#Param backendTexture  texture residing on GPU ##
#Param origin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param colorType  one of: kUnknown_SkColorType, kAlpha_8_SkColorType,
                          kRGB_565_SkColorType, kARGB_4444_SkColorType,
                          kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,
                          kGray_8_SkColorType, kRGBA_F16_SkColorType
##
#Param alphaType  one of: kUnknown_SkAlphaType, kOpaque_SkAlphaType,
                          kPremul_SkAlphaType, kUnpremul_SkAlphaType
##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

#Example
#Image 3
#Platform gpu
#Height 128
#Description
A back-end texture has been created and uploaded to the GPU outside of this example.
##
GrContext* context = canvas->getGrContext();
if (!context) {
   return;
}
canvas->scale(.25f, .25f);
int x = 0;
for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {
    sk_sp<SkImage> image = SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,
           origin, kOpaque_SkAlphaType, nullptr);
    canvas->drawImage(image, x, 0);
x += 512;
}
##

#SeeAlso MakeFromAdoptedTexture SkSurface::MakeFromBackendTexture

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromTexture(GrContext* context,
                                          const GrBackendTexture& backendTexture,
                                          GrSurfaceOrigin origin,
                                          SkColorType colorType,
                                          SkAlphaType alphaType,
                                          sk_sp<SkColorSpace> colorSpace,
                                          TextureReleaseProc textureReleaseProc,
                                          ReleaseContext releaseContext)

Creates Image from GPU_Texture associated with context. GPU_Texture must stay
valid and unchanged until textureReleaseProc is called. textureReleaseProc is
passed releaseContext when Image is deleted or no longer refers to texture.

Image is returned if format of backendTexture is recognized and supported.
Recognized formats vary by GPU back-end.

#Param context  GPU_Context ##
#Param backendTexture  texture residing on GPU ##
#Param origin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param colorType  one of: kUnknown_SkColorType, kAlpha_8_SkColorType,
                          kRGB_565_SkColorType, kARGB_4444_SkColorType,
                          kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,
                          kGray_8_SkColorType, kRGBA_F16_SkColorType
##
#Param alphaType  one of: kUnknown_SkAlphaType, kOpaque_SkAlphaType,
                          kPremul_SkAlphaType, kUnpremul_SkAlphaType
##
#Param colorSpace  range of colors; may be nullptr ##
#Param textureReleaseProc  function called when texture can be released ##
#Param releaseContext  state passed to textureReleaseProc ##

#Return created Image, or nullptr ##

#ToDo
This doesn't do anything clever with TextureReleaseProc because it may not get called
fwithin the lifetime of the example
##

#Example
GrContext* context = canvas->getGrContext();
if (!context) {
   return;
}
auto debugster = [](SkImage::ReleaseContext context) -> void {
    *((int *) context) += 128;
};
int x = 0;
for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {
    sk_sp<SkImage> image = SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,
           origin, kRGBA_8888_SkColorType, kOpaque_SkAlphaType, nullptr, debugster, &x);
    canvas->drawImage(image, x, 0);
    x += 128;
}
##

#SeeAlso MakeFromAdoptedTexture SkSurface::MakeFromBackendTexture

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeCrossContextFromEncoded(GrContext* context, sk_sp<SkData> data,
                                                      bool buildMips,
                                                      SkColorSpace* dstColorSpace)

Creates Image from encoded data. Image is uploaded to GPU back-end using context. 

Created Image is available to other GPU contexts, and is available across thread
boundaries. All contexts must be in the same GPU_Share_Group, or otherwise 
share resources.

When Image is no longer referenced, context releases texture memory
asynchronously.

Texture decoded from data is uploaded to match Surface created with
dstColorSpace. Color_Space of Image is determined by encoded data.

Image is returned if format of data is recognized and supported, and if context
supports moving resources. Recognized formats vary by platform and GPU back-end.

Image is returned using MakeFromEncoded if context is nullptr or does not support
moving resources between contexts.

#Param context  GPU_Context ##
#Param data  Image to decode ##
#Param buildMips  create Image as Mip_Map if true ##
#Param dstColorSpace  range of colors of matching Surface on GPU ##

#Return created Image, or nullptr ##

#Example
#Image 4
#Height 128
GrContext* context = canvas->getGrContext();
sk_sp<SkData> encodedData = image->encodeToData(SkEncodedImageFormat::kJPEG, 100);
sk_sp<SkImage> image = SkImage::MakeCrossContextFromEncoded(context,
                                                            encodedData, false, nullptr);
canvas->drawImage(image, 0, 0);
##

#SeeAlso MakeCrossContextFromPixmap

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeCrossContextFromPixmap(GrContext* context, const SkPixmap& pixmap,
                                                      bool buildMips,
                                                      SkColorSpace* dstColorSpace)

Creates Image from pixmap. Image is uploaded to GPU back-end using context. 

Created Image is available to other GPU contexts, and is available across thread
boundaries. All contexts must be in the same GPU_Share_Group, or otherwise 
share resources.

When Image is no longer referenced, context releases texture memory
asynchronously.

Texture created from pixmap is uploaded to match Surface created with
dstColorSpace. Color_Space of Image is determined by pixmap.colorSpace().

Image is returned referring to GPU back-end if context is not nullptr, 
format of data is recognized and supported, and if context supports moving
resources between contexts. Otherwise, pixmap pixel data is copied and Image
as returned in raster format if possible; nullptr may be returned.
Recognized GPU formats vary by platform and GPU back-end.

#Param context  GPU_Context ##
#Param pixmap  Image_Info, pixel address, and row bytes ##
#Param buildMips  create Image as Mip_Map if true ##
#Param dstColorSpace  range of colors of matching Surface on GPU ##

#Return created Image, or nullptr ##

#Example
#Image 4
#Height 128
GrContext* context = canvas->getGrContext();
SkPixmap pixmap;
if (source.peekPixels(&pixmap)) {
    sk_sp<SkImage> image = SkImage::MakeCrossContextFromPixmap(context, pixmap,
                                                               false, nullptr);
    canvas->drawImage(image, 0, 0);
}
##

#SeeAlso MakeCrossContextFromEncoded

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromAdoptedTexture(GrContext* context,
                                                 const GrBackendTexture& backendTexture,
                                                 GrSurfaceOrigin surfaceOrigin,
                                                 SkAlphaType alphaType = kPremul_SkAlphaType,
                                                 sk_sp<SkColorSpace> colorSpace = nullptr)

Deprecated.

#Param context  GPU_Context ##
#Param backendTexture  texture residing on GPU ##
#Param surfaceOrigin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param alphaType  one of: kUnknown_SkAlphaType, kOpaque_SkAlphaType,
                          kPremul_SkAlphaType, kUnpremul_SkAlphaType
##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

#NoExample
##

#SeeAlso MakeFromTexture MakeFromYUVTexturesCopy

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromAdoptedTexture(GrContext* context,
                                                 const GrBackendTexture& backendTexture,
                                                 GrSurfaceOrigin surfaceOrigin,
                                                 SkColorType colorType,
                                                 SkAlphaType alphaType = kPremul_SkAlphaType,
                                                 sk_sp<SkColorSpace> colorSpace = nullptr)

Creates Image from backendTexture associated with context. backendTexture and
returned Image are managed internally, and are released when no longer needed.

Image is returned if format of backendTexture is recognized and supported.
Recognized formats vary by GPU back-end.

#Param context  GPU_Context ##
#Param backendTexture  texture residing on GPU ##
#Param surfaceOrigin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param colorType  one of: kUnknown_SkColorType, kAlpha_8_SkColorType,
                          kRGB_565_SkColorType, kARGB_4444_SkColorType,
                          kRGBA_8888_SkColorType, kBGRA_8888_SkColorType,
                          kGray_8_SkColorType, kRGBA_F16_SkColorType
##
#Param alphaType  one of: kUnknown_SkAlphaType, kOpaque_SkAlphaType,
                          kPremul_SkAlphaType, kUnpremul_SkAlphaType
##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

#Example
   if (!canvas->getGrContext()) {
       return;
   }
   canvas->scale(.5f, .5f);
   canvas->clear(0x7f3f5f7f);
   int x = 0, y = 0;
   for (auto origin : { kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin } ) {
       for (auto alpha : { kOpaque_SkAlphaType, kPremul_SkAlphaType, kUnpremul_SkAlphaType } ) {
           sk_sp<SkImage> image = SkImage::MakeFromAdoptedTexture(canvas->getGrContext(),
                                                                  backEndTexture, origin, 
                                                                  kRGBA_8888_SkColorType, alpha);
           canvas->drawImage(image, x, y);
           x += 160;
       }
       x -= 160 * 3;
       y += 256;
   }
##

#SeeAlso MakeFromTexture MakeFromYUVTexturesCopy

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromYUVTexturesCopy(GrContext* context, SkYUVColorSpace yuvColorSpace,
                                                  const GrBackendObject yuvTextureHandles[3],
                                                  const SkISize yuvSizes[3],
                                                  GrSurfaceOrigin surfaceOrigin,
                                                  sk_sp<SkColorSpace> colorSpace = nullptr)

Creates Image from copy of yuvTextureHandles, an array of textures on GPU.
yuvTextureHandles contain pixels for YUV planes of Image.
yuvSizes conain dimensions for each pixel plane. Dimensions must be greater than
zero but may differ from plane to plane. Returned Image has the dimensions
yuvSizes[0]. yuvColorSpace describes how YUV colors convert to RGB colors. 

#Param context  GPU_Context ##
#Param yuvColorSpace  one of: kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace,
                              kRec709_SkYUVColorSpace
##
#Param yuvTextureHandles  array of YUV textures on GPU ##
#Param yuvSizes  dimensions of YUV textures ##
#Param surfaceOrigin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

# seems too complicated to create an example for this
#ToDo
should this be moved to chrome only?
##

#NoExample
##

#SeeAlso MakeFromNV12TexturesCopy

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromYUVTexturesCopy(GrContext* context, SkYUVColorSpace yuvColorSpace,
                                                  const GrBackendTexture yuvTextureHandles[3],
                                                  const SkISize yuvSizes[3],
                                                  GrSurfaceOrigin surfaceOrigin,
                                                  sk_sp<SkColorSpace> colorSpace = nullptr)

Creates Image from copy of yuvTextureHandles, an array of textures on GPU.
yuvTextureHandles contain pixels for YUV planes of Image.
yuvSizes conain dimensions for each pixel plane. Dimensions must be greater than
zero but may differ from plane to plane. Returned Image has the dimensions
yuvSizes[0]. yuvColorSpace describes how YUV colors convert to RGB colors. 

#Param context  GPU_Context ##
#Param yuvColorSpace  one of: kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace,
                              kRec709_SkYUVColorSpace
##
#Param yuvTextureHandles  array of YUV textures on GPU ##
#Param yuvSizes  dimensions of YUV textures ##
#Param surfaceOrigin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

# seems too complicated to create an example for this
#ToDo
should this be moved to chrome only?
##

#NoExample
##

#SeeAlso MakeFromNV12TexturesCopy

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromNV12TexturesCopy(GrContext* context,
                                                   SkYUVColorSpace yuvColorSpace,
                                                   const GrBackendObject nv12TextureHandles[2],
                                                   const SkISize nv12Sizes[2],
                                                   GrSurfaceOrigin surfaceOrigin,
                                                   sk_sp<SkColorSpace> colorSpace = nullptr)

Creates Image from copy of nv12TextureHandles, an array of textures on GPU.
nv12TextureHandles[0] contains pixels for YUV_Component_Y plane.
nv12TextureHandles[1] contains pixels for YUV_Component_U plane,
followed by pixels for YUV_Component_V plane.
nv12Sizes conain dimensions for each pixel plane. Dimensions must be greater than
zero but may differ from plane to plane. Returned Image has the dimensions
nv12Sizes[0]. yuvColorSpace describes how YUV colors convert to RGB colors.

#Param context  GPU_Context ##
#Param yuvColorSpace  one of: kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace,
                              kRec709_SkYUVColorSpace
##
#Param nv12TextureHandles  array of YUV textures on GPU ##
#Param nv12Sizes  dimensions of YUV textures ##
#Param surfaceOrigin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

# seems too complicated to create an example for this
#ToDo
should this be moved to chrome only?
##

#NoExample
##

#SeeAlso MakeFromYUVTexturesCopy

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromNV12TexturesCopy(GrContext* context,
                                                   SkYUVColorSpace yuvColorSpace,
                                                   const GrBackendTexture nv12TextureHandles[2],
                                                   const SkISize nv12Sizes[2],
                                                   GrSurfaceOrigin surfaceOrigin,
                                                   sk_sp<SkColorSpace> colorSpace = nullptr)

Creates Image from copy of nv12TextureHandles, an array of textures on GPU.
nv12TextureHandles[0] contains pixels for YUV_Component_Y plane.
nv12TextureHandles[1] contains pixels for YUV_Component_U plane,
followed by pixels for YUV_Component_V plane.
nv12Sizes conain dimensions for each pixel plane. Dimensions must be greater than
zero but may differ from plane to plane. Returned Image has the dimensions
nv12Sizes[0]. yuvColorSpace describes how YUV colors convert to RGB colors.

#Param context  GPU_Context ##
#Param yuvColorSpace  one of: kJPEG_SkYUVColorSpace, kRec601_SkYUVColorSpace,
                              kRec709_SkYUVColorSpace
##
#Param nv12TextureHandles  array of YUV textures on GPU ##
#Param nv12Sizes  dimensions of YUV textures ##
#Param surfaceOrigin  one of: kBottomLeft_GrSurfaceOrigin, kTopLeft_GrSurfaceOrigin ##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

# seems too complicated to create an example for this
#ToDo
should this be moved to chrome only?
##

#NoExample
##

#SeeAlso MakeFromYUVTexturesCopy

#Method ##

# ------------------------------------------------------------------------------

#Bug 7424
currently uncalled by any test or client
##

#Enum BitDepth

#Code
    enum class BitDepth {
        kU8,
        kF16,
    };
##

#Const kU8 0
Use 8 bits per Color_ARGB component using unsigned integer format.
##
#Const kF16 1
Use 16 bits per Color_ARGB component using half-precision floating point format.  
##

#NoExample
##

#SeeAlso MakeFromPicture

#Enum ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromPicture(sk_sp<SkPicture> picture, const SkISize& dimensions,
                                          const SkMatrix* matrix, const SkPaint* paint,
                                          BitDepth bitDepth,
                                          sk_sp<SkColorSpace> colorSpace)

Creates Image from picture. Returned Image width and height are set by dimensions.
Image draws picture with matrix and paint, set to bitDepth and colorSpace.

If matrix is nullptr, draws with identity Matrix. If paint is nullptr, draws
with default Paint. colorSpace may be nullptr. 

#Param picture  stream of drawing commands ##
#Param dimensions  width and height ##
#Param matrix  Matrix to rotate, scale, translate, and so on; may be nullptr ##
#Param paint  Paint to apply transparency, filtering, and so on; may be nullptr ##
#Param bitDepth  8 bit integer or 16 bit float: per component ##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

#Example
    SkPaint paint;
    SkPictureRecorder recorder;
    SkCanvas* recordingCanvas = recorder.beginRecording(50, 50);
    for (auto color : { SK_ColorRED, SK_ColorBLUE, 0xff007f00 } ) {
        paint.setColor(color);
        recordingCanvas->drawRect({10, 10, 30, 40}, paint);
        recordingCanvas->translate(10, 10);
        recordingCanvas->scale(1.2f, 1.4f);
    }
    sk_sp<SkPicture> playback = recorder.finishRecordingAsPicture();
    int x = 0, y = 0;
    for (auto alpha : { 70, 140, 210 } ) {
        paint.setAlpha(alpha);
        auto srgbColorSpace = SkColorSpace::MakeSRGB();
        sk_sp<SkImage> image = SkImage::MakeFromPicture(playback, {50, 50}, nullptr, &paint,
                                                        SkImage::BitDepth::kU8, srgbColorSpace);
        canvas->drawImage(image, x, y);
        x += 70; y += 70;
    }
##

#SeeAlso SkCanvas::drawPicture

#Method ##

# ------------------------------------------------------------------------------

#Method static sk_sp<SkImage> MakeFromAHardwareBuffer(AHardwareBuffer* hardwareBuffer,
                                                 SkAlphaType alphaType = kPremul_SkAlphaType,
                                                 sk_sp<SkColorSpace> colorSpace = nullptr)

#Bug 7447 ##

Creates Image from Android hardware buffer.
Returned Image takes a reference on the buffer.

Only available on Android, when __ANDROID_API__ is defined to be 26 or greater.

#Param hardwareBuffer  AHardwareBuffer Android hardware buffer ##
#Param alphaType  one of: kUnknown_SkAlphaType, kOpaque_SkAlphaType,
                          kPremul_SkAlphaType, kUnpremul_SkAlphaType
##
#Param colorSpace  range of colors; may be nullptr ##

#Return created Image, or nullptr ##

#NoExample
##

#SeeAlso MakeFromRaster

#Method ##

# ------------------------------------------------------------------------------

#Method int width() const

Returns pixel count in each row.

#Return pixel width in Image ##

#Example
#Image 4
#Height 168
   canvas->translate(10, 10);
   canvas->drawImage(image, 0, 0);
   canvas->translate(0, image->height());
   SkPaint paint;
   paint.setTextAlign(SkPaint::kCenter_Align);
   canvas->drawLine(0, 10, image->width(), 10, paint);
   canvas->drawString("width", image->width() / 2, 25, paint);
##

#SeeAlso dimensions() height()

#Method ##

# ------------------------------------------------------------------------------

#Method int height() const

Returns pixel row count.

#Return pixel height in Image ##

#Example
#Image 4
#Height 148
   canvas->translate(10, 10);
   canvas->drawImage(image, 0, 0);
   canvas->translate(image->width(), 0);
   SkPaint paint;
   paint.setTextAlign(SkPaint::kCenter_Align);
   paint.setVerticalText(true);
   canvas->drawLine(10, 0, 10, image->height(), paint);
   canvas->drawString("height", 25, image->height() / 2, paint);##

#SeeAlso dimensions() width()

#Method ##

# ------------------------------------------------------------------------------

#Method SkISize dimensions() const

Returns ISize { width(), height() }.

#Return integral size of width() and height() ##

#Example
#Image 4
    SkISize dimensions = image->dimensions();
    SkIRect bounds = image->bounds();
    SkIRect dimensionsAsBounds = SkIRect::MakeSize(dimensions);
    SkDebugf("dimensionsAsBounds %c= bounds\n", dimensionsAsBounds == bounds ? '=' : '!');
##

#SeeAlso height() width() bounds()

#Method ##

# ------------------------------------------------------------------------------

#Method SkIRect bounds() const

Returns IRect { 0, 0, width(), height() }.

#Return integral rectangle from origin to width() and height() ##

#Example
#Height 128
#Image 4
    canvas->scale(.5f, .5f);
    SkIRect bounds = image->bounds();
    for (int x : { 0, image->width() } ) {
        for (int y : { 0, image->height() } ) {
            canvas->drawImage(image, x, y);
        }
    }
##

#SeeAlso dimensions() 

#Method ##

# ------------------------------------------------------------------------------

#Method uint32_t uniqueID() const

Returns value unique to image. Image contents cannot change after Image is
created. Any operation to create a new Image will receive generate a new
unique number.

#Return unique identifier ##

#Example
#Image 5
#Height 156
 sk_sp<SkImage> subset = image->makeSubset({10, 20, 90, 100});
 canvas->drawImage(image, 0, 0);
 canvas->drawImage(subset, 128, 0);
 SkPaint paint;
 SkString s;
 s.printf("original id: %d", image->uniqueID());
 canvas->drawString(s, 20, image->height() + 20, paint);
 s.printf("subset id: %d", subset->uniqueID());
 canvas->drawString(s, 148, subset->height() + 20, paint);
##

#SeeAlso isLazyGenerated

#Method ##

# ------------------------------------------------------------------------------

#Method SkAlphaType alphaType() const

Returns Alpha_Type, one of: kUnknown_SkAlphaType, kOpaque_SkAlphaType,
kPremul_SkAlphaType, kUnpremul_SkAlphaType.

Alpha_Type returned was a parameter to an Image constructor,
or was parsed from encoded data.

#Return Alpha_Type in Image ##

#Example
#Image 4
#Height 156
  const char* alphaTypeStr[] = { "Unknown", "Opaque", "Premul", "Unpremul" };
  SkAlphaType alphaType = image->alphaType();
  canvas->drawImage(image, 0, 0);
  SkPaint paint;
  canvas->drawString(alphaTypeStr[(int) alphaType], 20, image->height() + 20, paint);
##

#SeeAlso SkImageInfo::alphaType

#Method ##

# ------------------------------------------------------------------------------

#Method SkColorSpace* colorSpace() const

Returns Color_Space, the range of colors, associated with Image.  The
reference count of Color_Space is unchanged. The returned Color_Space is
immutable.

Color_Space returned was passed to an Image constructor,
or was parsed from encoded data. Color_Space returned may be ignored when Image
is drawn, depending on the capabilities of the Surface receiving the drawing.

#Return Color_Space in Image, or nullptr ##

#Example
#Image 3
#Set sRGB
    SkPixmap pixmap;
    source.peekPixels(&pixmap);
    canvas->scale(.25f, .25f);
    int y = 0;
    for (auto gamma : { SkColorSpace::kLinear_RenderTargetGamma,
                        SkColorSpace::kSRGB_RenderTargetGamma } ) {
        int x = 0;
        sk_sp<SkColorSpace> colorSpace = SkColorSpace::MakeRGB(gamma, SkColorSpace::kSRGB_Gamut);
        for (int index = 0; index < 2; ++index) {
            pixmap.setColorSpace(colorSpace);
            sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);
            canvas->drawImage(image, x, y);
            colorSpace = image->colorSpace()->makeColorSpin();
            x += 512;
        }
        y += 512;
    }
##

#SeeAlso refColorSpace makeColorSpace

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkColorSpace> refColorSpace() const

Returns a smart pointer to Color_Space, the range of colors, associated with
Image.  The smart pointer tracks the number of objects sharing this
SkColorSpace reference so the memory is released when the owners destruct.

The returned SkColorSpace is immutable.

Color_Space returned was passed to an Image constructor,
or was parsed from encoded data. Color_Space returned may be ignored when Image
is drawn, depending on the capabilities of the Surface receiving the drawing.

#Return Color_Space in Image, or nullptr, wrapped in a smart pointer ##

#Example
#Image 3
#Set sRGB
    SkPixmap pixmap;
    source.peekPixels(&pixmap);
    canvas->scale(.25f, .25f);
    int y = 0;
    for (auto gamma : { SkColorSpace::kLinear_RenderTargetGamma,
                        SkColorSpace::kSRGB_RenderTargetGamma } ) {
        int x = 0;
        sk_sp<SkColorSpace> colorSpace = SkColorSpace::MakeRGB(gamma, SkColorSpace::kSRGB_Gamut);
        for (int index = 0; index < 2; ++index) {
            pixmap.setColorSpace(colorSpace);
            sk_sp<SkImage> image = SkImage::MakeRasterCopy(pixmap);
            canvas->drawImage(image, x, y);
            colorSpace = image->refColorSpace()->makeColorSpin();
            x += 512;
        }
        y += 512;
    }
##

#SeeAlso colorSpace makeColorSpace

#Method ##

# ------------------------------------------------------------------------------

#Method bool isAlphaOnly() const

Returns true if Image pixels represent transparency only. If true, each pixel
is packed in 8 bits as defined by kAlpha_8_SkColorType.

#Return true if pixels represent a transparency mask ##

#Example
    uint8_t pmColors = 0;
    sk_sp<SkImage> image = SkImage::MakeRasterCopy({SkImageInfo::MakeA8(1, 1), &pmColors, 1});
    SkDebugf("alphaOnly = %s\n", image->isAlphaOnly() ? "true" : "false");
#StdOut
alphaOnly = true
##
##

#SeeAlso alphaType isOpaque

#Method ##

# ------------------------------------------------------------------------------

#Method bool isOpaque() const

Returns true if pixels ignore their Alpha value and are treated as fully opaque.

#Return true if Alpha_Type is kOpaque_SkAlphaType ##

#Example
    auto check_isopaque = [](const SkImageInfo& imageInfo) -> void {
        auto surface(SkSurface::MakeRaster(imageInfo));
        auto image(surface->makeImageSnapshot());
        SkDebugf("isOpaque = %s\n", image->isOpaque() ? "true" : "false");
    };

    check_isopaque(SkImageInfo::MakeN32Premul(5, 5));
    check_isopaque(SkImageInfo::MakeN32(5, 5, kOpaque_SkAlphaType));
#StdOut
isOpaque = false
isOpaque = true
##
##

#SeeAlso alphaType isAlphaOnly

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkShader> makeShader(SkShader::TileMode tileMode1, SkShader::TileMode tileMode2,
                               const SkMatrix* localMatrix = nullptr) const

Creates Shader from Image. Shader dimensions are taken from Image. Shader uses
SkShader::TileMode rules to fill drawn area outside Image. localMatrix permits
transforming Image before Canvas_Matrix is applied.

#Param tileMode1  tiling in x, one of: SkShader::kClamp_TileMode, SkShader::kRepeat_TileMode,
                  SkShader::kMirror_TileMode
##
#Param tileMode2  tiling in y, one of: SkShader::kClamp_TileMode, SkShader::kRepeat_TileMode,
                  SkShader::kMirror_TileMode
##
#Param localMatrix  Image transformation, or nullptr ##

#Return Shader containing Image ##

#Example
#Image 4
SkMatrix matrix;
matrix.setRotate(45);
SkPaint paint;
paint.setShader(image->makeShader(SkShader::kRepeat_TileMode, SkShader::kMirror_TileMode,
                                  &matrix));
canvas->drawPaint(paint);
##

#SeeAlso scalePixels

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkShader> makeShader(const SkMatrix* localMatrix = nullptr) const

Creates Shader from Image. Shader dimensions are taken from Image. Shader uses
SkShader::kClamp_TileMode to fill drawn area outside Image. localMatrix permits
transforming Image before Canvas_Matrix is applied.

#Param localMatrix  Image transformation, or nullptr ##

#Return Shader containing Image ##

#Example
#Image 5
SkMatrix matrix;
matrix.setRotate(45);
matrix.postTranslate(125, 30);
SkPaint paint;
paint.setShader(image->makeShader(&matrix));
canvas->drawPaint(paint);
##

#SeeAlso scalePixels

#Method ##

# ------------------------------------------------------------------------------

#Method bool peekPixels(SkPixmap* pixmap) const

Copies Image pixel address, row bytes, and Image_Info to pixmap, if address
is available, and returns true. If pixel address is not available, return
false and leave pixmap unchanged.

#Param pixmap  storage for pixel state if pixels are readable; otherwise, ignored ##

#Return true if Image has direct access to pixels ##

#Example
    SkBitmap bitmap;
    bitmap.allocPixels(SkImageInfo::MakeN32Premul(12, 11));
    SkCanvas offscreen(bitmap);
    offscreen.clear(SK_ColorWHITE);
    SkPaint paint;
    offscreen.drawString("%", 1, 10, paint);
    sk_sp<SkImage> image = SkImage::MakeFromBitmap(bitmap);
    SkPixmap pixmap;
    if (image->peekPixels(&pixmap)) {
        const SkPMColor* pixels = pixmap.addr32();
        SkPMColor pmWhite = pixels[0];
        for (int y = 0; y < image->height(); ++y) {
            for (int x = 0; x < image->width(); ++x) {
                SkDebugf("%c", *pixels++ == pmWhite ? '-' : 'x');
            }
            SkDebugf("\n");
        }
    }
#StdOut
------------
--xx----x---
-x--x--x----
-x--x--x----
-x--x-x-----
--xx-xx-xx--
-----x-x--x-
----x--x--x-
----x--x--x-
---x----xx--
------------
##
##

#SeeAlso readPixels

#Method ##

# ------------------------------------------------------------------------------

#Method GrTexture* getTexture() const

Deprecated.
 
#Deprecated 
##

#Private
Currently used by Canvas2DLayerBridge in Chromium.
##

#Method ##

# ------------------------------------------------------------------------------

#Method bool isTextureBacked() const

Returns true the contents of Image was created on or uploaded to GPU memory,
and is available as a GPU_Texture.

#Return true if Image is a GPU_Texture ##

#Example
#Image 5
#Platform gpu
auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {
    if (nullptr == image) {
        return;
    }
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    canvas->drawImage(image, 0, 0);
    canvas->drawString(label, image->width() / 2, image->height() / 4, paint);
    canvas->drawString(image->isTextureBacked() ? "is GPU texture" : "not GPU texture",
                       image->width() / 2, image->height() * 3 / 4, paint);
};
sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));
sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,
                            kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));
drawImage(image, "image");
canvas->translate(image->width(), 0);
drawImage(bitmapImage, "source");
canvas->translate(-image->width(), image->height());
drawImage(textureImage, "backEndTexture");
##

#SeeAlso MakeFromTexture isValid

#Method ##

# ------------------------------------------------------------------------------

#Method bool isValid(GrContext* context) const

Returns true if Image can be drawn on either Raster_Surface or GPU_Surface.
If context is nullptr, tests if Image draws on Raster_Surface;
otherwise, tests if Image draws on GPU_Surface associated with context.

Image backed by GPU_Texture may become invalid if associated GrContext is
invalid. Lazy_Image may be invalid and may not draw to Raster_Surface or
GPU_Surface or both.

#Param context  GPU_Context ##

#Return true if Image can be drawn  ##

#Example
#Image 5
#Platform gpu
auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {
    if (nullptr == image) {
        return;
    }
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    canvas->drawImage(image, 0, 0);
    canvas->drawString(label, image->width() / 2, image->height() / 4, paint);
    if (canvas->getGrContext()) {
        canvas->drawString(image->isValid(canvas->getGrContext()) ? "is valid on GPU" :
                "not valid on GPU", image->width() / 2, image->height() * 5 / 8, paint);
    }
    canvas->drawString(image->isValid(nullptr) ? "is valid on CPU" :
            "not valid on CPU", image->width() / 2, image->height() * 7 / 8, paint);
};
sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));
sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,
                            kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));
drawImage(image, "image");
canvas->translate(image->width(), 0);
drawImage(bitmapImage, "source");
canvas->translate(-image->width(), image->height());
drawImage(textureImage, "backEndTexture");
##

#SeeAlso isTextureBacked isLazyGenerated

#Method ##

# ------------------------------------------------------------------------------

#Method GrBackendObject getTextureHandle(bool flushPendingGrContextIO,
                                     GrSurfaceOrigin* origin = nullptr) const

Retrieves the back-end API handle of texture. If flushPendingGrContextIO is true,
complete deferred I/O operations.

If origin in not nullptr, copies location of content drawn into Image.

#Param flushPendingGrContextIO  flag to flush outstanding requests ##
#Param origin  storage for one of: kTopLeft_GrSurfaceOrigin,
               kBottomLeft_GrSurfaceOrigin; or nullptr 
##

#Return back-end API texture handle ##

#Example
#Image 3
#Platform gpu
GrContext* context = canvas->getGrContext();
if (!context) {
   return;
}
SkPaint paint;
paint.setAntiAlias(true);
SkString str;
int y = 0;
for (auto origin : { kTopLeft_GrSurfaceOrigin, kBottomLeft_GrSurfaceOrigin } ) {
    sk_sp<SkImage> srcImage(SkImage::MakeFromTexture(context,
            backEndTexture, origin, kPremul_SkAlphaType, nullptr));
    GrSurfaceOrigin readBackOrigin;
    GrBackendObject readBackHandle = srcImage->getTextureHandle(false, &readBackOrigin);
    str.printf("readBackHandle: %x", readBackHandle);
    canvas->drawString(str, 5, y += 20, paint);
    str.printf("origin: k%s_GrSurfaceOrigin", readBackOrigin ? "BottomLeft" : "TopLeft");
    canvas->drawString(str, 5, y += 20, paint);
}
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Enum CachingHint

#Code
    enum CachingHint {
        kAllow_CachingHint,
        kDisallow_CachingHint,
    };
##

Hints to image calls where the system might cache computed intermediates (e.g. the results
of decoding or a read-back from the GPU. Passing kAllow_CachingHint signals that the system's default
behavior is fine. Passing kDisallow_CachingHint signals that caching should be avoided.

#Const kAllow_CachingHint 0
##
#Const kDisallow_CachingHint 1
##

#Example
// incomplete
##

#SeeAlso incomplete

#Enum ##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkImageInfo& dstInfo, void* dstPixels, size_t dstRowBytes,
                    int srcX, int srcY, CachingHint cachingHint = kAllow_CachingHint) const

Copy the pixels from the image into the specified buffer (dstPixels + dstRowBytes),
converting them into the requested format (dstInfo). The image pixels are read
starting at the specified (srcX, srcY) location.
dstInfo and (srcX, srcY) offset specifies a source rectangle:
#Code
SkRect srcR;
srcR.setXYWH(srcX, srcY, dstInfo.width(), dstInfo.height());
##

The source rectangle is intersected with the bounds of the image. If this intersection is not empty,
then we have two sets of pixels (of equal size). Replace dstPixels with the
corresponding Image pixels, performing any Color_Type/Alpha_Type transformations needed
(in the case where Image and dstInfo have different Color_Types or Alpha_Types).
This call can fail, returning false, for several reasons:
if source rectangle does not intersect the image bounds;
if the requested Color_Type/Alpha_Type cannot be converted from the image's types.

#Param dstInfo  incomplete ##
#Param dstPixels  incomplete ##
#Param dstRowBytes  incomplete ##
#Param srcX  incomplete ##
#Param srcY  incomplete ##
#Param cachingHint  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method bool readPixels(const SkPixmap& dst, int srcX, int srcY,
                    CachingHint cachingHint = kAllow_CachingHint) const

#Param dst  incomplete ##
#Param srcX  incomplete ##
#Param srcY  incomplete ##
#Param cachingHint  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method bool scalePixels(const SkPixmap& dst, SkFilterQuality filterQuality,
                     CachingHint cachingHint = kAllow_CachingHint) const

Copies Image pixels into dst, converting to dst Color_Type and Alpha_Type.
If the conversion cannot be performed, false is returned.
If dst dimensions differ from Image dimensions, Image is scaled, applying
filterQuality.

#Param dst  incomplete ##
#Param filterQuality  incomplete ##
#Param cachingHint  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkData> encodeToData(SkEncodedImageFormat encodedImageFormat, int quality) const

Encodes Image pixels, returning result as SkData.

Returns nullptr if encoding fails, or encodedImageFormat is not supported.

#Param encodedImageFormat  incomplete ##
#Param quality  incomplete ##

#Return encoded Image, or nullptr ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkData> encodeToData() const

Encodes Image and returns result as SkData. Will reuse existing encoded data
if present, as returned by refEncodedData. If encoded data is missing or invalid,
Image is encoded as PNG.

Returns nullptr if existing encoded data is missing or invalid and 
encoding fails.

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkData> refEncodedData() const

If the image already has its contents in encoded form (e.g. PNG or JPEG), return that
as SkData. If the image does not already has its contents in encoded form, return nullptr.

To force the image to return its contents as encoded data, call encodeToData.

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method const char* toString(SkString* string) const

#Param string  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkImage> makeSubset(const SkIRect& subset) const

Return a new image that is a subset of this image. The underlying implementation may
share the pixels, or it may make a copy.
If subset does not intersect the bounds of this image, or the copy/share cannot be made,
nullptr will be returned.

#Param subset  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkImage> makeTextureImage(GrContext* context, SkColorSpace* dstColorSpace) const

Ensures that an image is backed by a texture (when GrContext is non-null), suitable for use
with surfaces that have the supplied destination color space. If no transformation is
required, the returned image may be the same as this image. If this image is from a
different GrContext, this will fail.

#Param context  GPU_Context ##
#Param dstColorSpace  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkImage> makeNonTextureImage() const

Creates raster Image if Image contains GPU_Texture and raster Image  ,  this will make a raster copy of it (or nullptr if reading back
the pixels fails). Otherwise, it returns the original image.

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkImage> makeRasterImage() const

If the image is texture-backed this will make a raster copy of it (or nullptr if reading back
the pixels fails). Otherwise, it returns the original image.

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkImage> makeWithFilter(const SkImageFilter* filter, const SkIRect& subset,
                                  const SkIRect& clipBounds, SkIRect* outSubset,
                                  SkIPoint* offset) const

Apply a given image filter to this image, and return the filtered result.
The subset represents the active portion of this image. The return value is similarly an
SkImage, with an active subset (outSubset). This is usually used with texture-backed
images, where the texture may be approx-match and thus larger than the required size.
clipBounds constrains the device-space extent of the image, stored in outSubset.
offset is storage, set to the amount to translate the result when drawn.
If the result image cannot be created, or the result would be transparent black, null
is returned, in which case the offset and outSubset parameters should be ignored by the
caller.

#Param filter  incomplete ##
#Param subset  incomplete ##
#Param clipBounds  incomplete ##
#Param outSubset  incomplete ##
#Param offset  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Struct DeferredTextureImageUsageParams

#Code
    struct DeferredTextureImageUsageParams {
        DeferredTextureImageUsageParams(const SkMatrix matrix, const SkFilterQuality quality,
                                        int preScaleMipLevel);
        SkMatrix        fMatrix;
        SkFilterQuality fQuality;
        int             fPreScaleMipLevel;
    };
##

#Member SkMatrix fMatrix
##

#Member SkFilterQuality fQuality
##

#Member int fPreScaleMipLevel
##

#Method         DeferredTextureImageUsageParams(const SkMatrix matrix, const SkFilterQuality quality,
                                        int preScaleMipLevel)

#Param matrix incomplete ##
#Param quality incomplete ##
#Param preScaleMipLevel incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

##

#Example
// incomplete
##

#SeeAlso incomplete

##

#Method size_t getDeferredTextureImageData(const GrContextThreadSafeProxy& contextThreadSafeProxy,
                            const DeferredTextureImageUsageParams deferredTextureImageUsageParams[],
                            int paramCnt,
                            void* buffer,
                            SkColorSpace* dstColorSpace = nullptr,
                            SkColorType dstColorType = kN32_SkColorType) const

This method allows clients to capture the data necessary to turn a SkImage into a texture-
backed image. If the original image is codec-backed this will decode into a format optimized
for the context represented by the proxy. This method is thread safe with respect to the
GrContext whence the proxy came. Clients allocate and manage the storage of the deferred
texture data and control its lifetime. No cleanup is required, thus it is safe to simply free
the memory out from under the data.

The same method is used both for getting the size necessary for pre-uploaded texture data
and for retrieving the data. The params array represents the set of draws over which to
optimize the pre-upload data.

When called with a null buffer this returns the size that the client must allocate in order
to create deferred texture data for this image (or zero if this is an inappropriate
candidate). The buffer allocated by the client should be 8 byte aligned.

When buffer is not null this fills in the deferred texture data for this image in the
provided buffer (assuming this is an appropriate candidate image and the buffer is
appropriately aligned). Upon success the size written is returned, otherwise 0.

dstColorSpace is the color space of the surface where this texture will ultimately be used.
If the method determines that mip-maps are needed, this helps determine the correct strategy
for building them (gamma-correct or not).

dstColorType is the color type of the surface where this texture will ultimately be used.
This determines the format with which the image will be uploaded to the GPU. If dstColorType
does not support color spaces (low bit depth types such as kARGB_4444_SkColorType),
then dstColorSpace must be null.

#Param contextThreadSafeProxy  incomplete ##
#Param deferredTextureImageUsageParams  incomplete ##
#Param paramCnt  incomplete ##
#Param buffer  incomplete ##
#Param dstColorSpace  incomplete ##
#Param dstColorType  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

##

#Method static sk_sp<SkImage> MakeFromDeferredTextureImageData(GrContext* context, const void* data,
                                                           SkBudgeted budgeted)

Returns a texture-backed image from data produced in SkImage::getDeferredTextureImageData.
The context must be the context that provided the proxy passed to
getDeferredTextureImageData.

#Param context GPU_Context ##
#Param data incomplete ##
#Param budgeted incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

##

# ------------------------------------------------------------------------------

#Typedef std::function<void(GrBackendTexture)> BackendTextureReleaseProc

##

# ------------------------------------------------------------------------------

#Method static bool MakeBackendTextureFromSkImage(GrContext* context,
                                              sk_sp<SkImage> image,
                                              GrBackendTexture* backendTexture,
                                              BackendTextureReleaseProc* backendTextureReleaseProc)

Creates a GrBackendTexture from the provided SkImage. Returns true on success. The
GrBackendTexture and BackendTextureReleaseProc are populated on success. It is the callers
responsibility to call the BackendTextureReleaseProc once they have deleted the texture.
Note that the BackendTextureReleaseProc allows Skia to clean up auxiliary data related
to the GrBackendTexture, and is not a substitute for the client deleting the GrBackendTexture
themselves.

If image is both texture backed and singly referenced; that is, its only
reference was transferred using std::move(): image is returned in backendTexture
without conversion or making a copy. 

If the SkImage is not texture backed, this function will generate a texture with the image's
contents and return that.

#Param context  GPU_Context ##
#Param image  incomplete ##
#Param backendTexture  incomplete ##
#Param backendTextureReleaseProc  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Enum LegacyBitmapMode

#Code
    enum LegacyBitmapMode {
        kRO_LegacyBitmapMode,
        kRW_LegacyBitmapMode,
    };
##

Helper functions to convert to SkBitmap

#Const kRO_LegacyBitmapMode 0
##
#Const kRW_LegacyBitmapMode 1
##

#Example
// incomplete
##

#SeeAlso incomplete

#Enum ##

# ------------------------------------------------------------------------------

#Method bool asLegacyBitmap(SkBitmap* bitmap, LegacyBitmapMode legacyBitmapMode) const

Creates raster Bitmap with same pixels as Image. If legacyBitmapMode is kRO_LegacyBitmapMode,
returned bitmap is read-only and immutable.
Returns true if Bitmap is stored in bitmap. Returns false and resets bitmap if Bitmap
write did not succeed.

#Param bitmap  storage for legacy Bitmap ##
#Param legacyBitmapMode  one of: kRO_LegacyBitmapMode, kRW_LegacyBitmapMode ##

#Return true if Bitmap was created ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method bool isLazyGenerated() const

Returns true if Image is backed by an image-generator or other service that creates
and caches its pixels or texture on-demand.

#Return true if Image is created as needed ##

#Example
#Height 80
#Function
class TestImageGenerator : public SkImageGenerator {
public:
    TestImageGenerator() : SkImageGenerator(SkImageInfo::MakeN32Premul(10, 10)) {}
    ~TestImageGenerator() override {}
protected:
    bool onGetPixels(const SkImageInfo& info, void* pixelPtr, size_t rowBytes,
                     const Options& options) override {
        SkPMColor* pixels = static_cast<SkPMColor*>(pixelPtr);
        for (int y = 0; y < info.height(); ++y) {
            for (int x = 0; x < info.width(); ++x) {
                pixels[y * info.width() + x] = 0xff223344 + y * 0x000C0811;
            }
        }
        return true;
    }
};
##
void draw(SkCanvas* canvas) {
    auto gen = std::unique_ptr<TestImageGenerator>(new TestImageGenerator());
    sk_sp<SkImage> image(SkImage::MakeFromGenerator(std::move(gen)));
    SkString lazy(image->isLazyGenerated() ? "is lazy" : "not lazy");
    canvas->scale(8, 8);
    canvas->drawImage(image, 0, 0, nullptr);
    SkPaint paint;
    paint.setTextSize(4);
    canvas->drawString(lazy, 2, 5, paint);
}
##

#Example
#Image 5
#Platform gpu
void draw(SkCanvas* canvas) {
    auto drawImage = [=](sk_sp<SkImage> image, const char* label) -> void {
        if (nullptr == image) {
            return;
        }
        SkPaint paint;
        paint.setAntiAlias(true);
        paint.setTextAlign(SkPaint::kCenter_Align);
        canvas->drawImage(image, 0, 0);
        canvas->drawString(label, image->width() / 2, image->height() / 4, paint);
        canvas->drawString(
                image->isLazyGenerated() ? "is lazily generated" : "not lazily generated",
                image->width() / 2, image->height() * 3 / 4, paint);
    };
    sk_sp<SkImage> bitmapImage(SkImage::MakeFromBitmap(source));
    sk_sp<SkImage> textureImage(SkImage::MakeFromTexture(canvas->getGrContext(), backEndTexture,
                                kTopLeft_GrSurfaceOrigin, kOpaque_SkAlphaType, nullptr));
    drawImage(image, "image");
    canvas->translate(image->width(), 0);
    drawImage(bitmapImage, "source");
    canvas->translate(-image->width(), image->height());
    drawImage(textureImage, "backEndTexture");
}
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method sk_sp<SkImage> makeColorSpace(sk_sp<SkColorSpace> target,
                                  SkTransferFunctionBehavior premulBehavior) const

If target is supported, returns an SkImage in target color space.
Otherwise, returns nullptr.
This will leave the image as is if it already in target color space.
Otherwise, it will convert the pixels from Image color space to target
color space.  If this->colorSpace() is nullptr, Image color space will be
treated as sRGB.

If premulBehavior is SkTransferFunctionBehavior::kRespect: converts Image
pixels to a linear space before converting to match destination Color_Type
and Color_Space.
If premulBehavior is SkTransferFunctionBehavior::kIgnore: Image
pixels are treated as if they are linear, regardless of how they are encoded.

#Param target  incomplete ##
#Param premulBehavior  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

#Class SkImage ##

#Topic Image ##
