#Topic RRect
#Alias Round_Rect ##
#Alias RRect_Reference ##

#Class SkRRect

#Private
Path forward:
   core work
      add contains(SkRect&)  - for clip stack
      add contains(SkRRect&) - for clip stack
      add heart rect computation (max rect inside RR)
      add 9patch rect computation
      add growToInclude(SkPath&)
   analysis
      use growToInclude to fit skp round rects & generate stats (RRs vs. real paths)
      check on # of rectorus's the RRs could handle
   rendering work
      update SkPath.addRRect() to only use quads
      add GM and bench
   further out
      detect and triangulate RRectorii rather than falling back to SW in Ganesh
##

The SkRRect class represents a rounded rect with a potentially different
radii for each corner. It does not have a constructor so must be
initialized with one of the initialization functions (e.g., setEmpty,
setRectRadii, etc.)

This class allows implementing CSS properties that describe rounded corners.
A rectangle may have up to eight radii, one for each axis on each of its four
corners.

If either corner's radii are zero, the corner is square.
Negative radii are treated as zero.
If corner curves overlap, they are proportionally reduced to fit.

#Subtopic Overview
#Populate
##

#Subtopic Constructor
#Populate
##

#Subtopic Operator
#Populate
##

#Subtopic Member_Function
#Populate
##

# ------------------------------------------------------------------------------

#Method SkRRect()
#In Constructor
#Line # creates with zeroed bounds and corner radii ##

Initializes bounds at (0, 0), the origin, with zero width and height.
Initializes corner radii to (0, 0), and sets type of kEmpty_Type.

#Return empty Round_Rect ##

#Example
#Height 60
    SkRRect rrect;
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    canvas->drawRRect(rrect, p);
    rrect.setRect({10, 10, 100, 50});
    canvas->drawRRect(rrect, p);
##

#SeeAlso setEmpty isEmpty

#Method ##

# ------------------------------------------------------------------------------

#Method SkRRect(const SkRRect& rrect)
#In Constructor
#Line # copies bounds and corner radii ##

Initializes to copy of rrect bounds and corner radii.

#Param rrect  bounds and corner to copy ##

#Return copy of rrect ##

#Bug 8115
#Example
    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});
    SkRRect rrect2(rrect);
    rrect2.inset(20, 20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    canvas->drawRRect(rrect, p);
    canvas->drawRRect(rrect2, p);
##

#SeeAlso operator=(const SkRRect& rrect) MakeRect

#Method ##

# ------------------------------------------------------------------------------

#Method SkRRect& operator=(const SkRRect& rrect)
#In Operator
#Line # copies bounds and corner radii ##

Copies rrect bounds and corner radii.

#Param rrect  bounds and corner to copy ##

#Return copy of rrect ##

#Example
    SkRRect rrect = SkRRect::MakeRect({40, 40, 100, 70});
    SkRRect rrect2 = rrect;
    rrect2.inset(-20, -20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    canvas->drawRRect(rrect, p);
    canvas->drawRRect(rrect2, p);
##

#SeeAlso SkRRect(const SkRRect& rrect) MakeRect

#Method ##

# ------------------------------------------------------------------------------
#Subtopic Type
#Line # specialization of Round_Rect geometry ##

#PhraseDef list_of_rrect_types
kEmpty_Type, kRect_Type, kOval_Type, kSimple_Type, kNinePatch_Type,
kComplex_Type
##

#Enum Type
#Line # specialization of Round_Rect geometry ##

#Code
    enum Type {
        kEmpty_Type,
        kRect_Type,
        kOval_Type,
        kSimple_Type,
        kNinePatch_Type,
        kComplex_Type,
        kLastType = kComplex_Type,
    };
##

Type describes possible specializations of Round_Rect. Each Type is
exclusive; a Round_Rect may only have one type. 

The enum members become progressively less restrictive; larger values of
Type have more degrees of freedom than smaller values.

#Const kEmpty_Type
#Line # zero width or height ##
Round_Rect has zero width or height. All radii are zero.
##
#Const kRect_Type
#Line # non-zero width and height, and zeroed radii ##
Round_Rect has width and height. All radii are zero.
##
#Const kOval_Type
#Line # non-zero width and height filled with radii ##
Round_Rect has width and height. All four x-radii are equal,
and at least half the width. All four y-radii are equal,
and at least half the height.
##
#Const kSimple_Type
#Line # non-zero width and height with equal radii ##
Round_Rect has width and height. All four x-radii are equal and
greater than zero, and all four y-radii are equal and greater than
zero. Either x-radii are less than half the width, or y-radii is
less than half the height, or both.
##
#Const kNinePatch_Type
#Line # non-zero width and height with axis-aligned radii ##
Round_Rect has width and height. Left x-radii are equal, top
y-radii are equal, right x-radii are equal, and bottom y-radii
are equal. The radii do not describe a rect, oval, or simple type.

The centers of the corner ellipses form an axis-aligned rectangle
that divides the Round_Rect into nine rectangular patches; an
interior rectangle, four edges, and four corners.
##
#Const kComplex_Type
#Line # non-zero width and height with arbitrary radii ##
both radii are non-zero.
##
#Const kLastType = kComplex_Type
#Line # largest Type value ##
##

#Example
#Height 128
    struct Radii { SkVector data[4]; };
    auto drawRRectType = [=](const SkRect& rect, const Radii& radii) {
        SkRRect rrect;
        rrect.setRectRadii(rect, radii.data);
        SkPaint paint;
        paint.setAntiAlias(true);
        const char* typeStr[] = { "empty", "rect", "oval", "simple", "nine patch", "complex" };
        paint.setTextAlign(SkPaint::kCenter_Align);
        canvas->drawString(typeStr[(int) rrect.type()], rect.centerX(), rect.bottom() + 20, paint);
        paint.setStyle(SkPaint::kStroke_Style);       
        canvas->drawRRect(rrect, paint);
    };
    drawRRectType({ 45,  30,  45,  30}, {{{ 5,  5}, { 5,  5}, { 5,  5}, { 5,  5}}});
    drawRRectType({ 90,  10, 140,  30}, {{{ 0,  0}, { 0,  0}, { 0,  0}, { 0,  0}}});
    drawRRectType({160,  10, 210,  30}, {{{25, 10}, {25, 10}, {25, 10}, {25, 10}}});
    drawRRectType({ 20,  80,  70, 100}, {{{ 5,  5}, { 5,  5}, { 5,  5}, { 5,  5}}});
    drawRRectType({ 90,  80, 140, 100}, {{{ 5,  5}, {10,  5}, {10,  5}, { 5,  5}}});
    drawRRectType({160,  80, 210, 100}, {{{ 5,  5}, {10,  5}, { 5,  5}, { 5,  5}}});
##

#SeeAlso Rect Path

#Enum ##

# ------------------------------------------------------------------------------

#Method Type getType() const
#In Property
#Line # returns Type ##

Returns Type, one of: #list_of_rrect_types#.

#Return Type ##

#Example
#Description 
rrect2 is not a Rect; inset() has made it empty.
##
    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});
    SkRRect rrect2(rrect);
    rrect2.inset(20, 20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    std::string str("Type ");
    str += SkRRect::kRect_Type == rrect2.getType() ? "=" : "!"; 
    str += "= SkRRect::kRect_Type";
    canvas->drawString(str.c_str(), 20, 80, SkPaint());
    canvas->drawRRect(rrect2, p);
##

#SeeAlso Type type

#Method ##

# ------------------------------------------------------------------------------

#Method Type type() const
#In Property
#Line # returns Type ##

Returns Type, one of: #list_of_rrect_types#.

#Return Type ##

#Example
#Description 
inset() has made rrect2 empty.
##
    SkRRect rrect = SkRRect::MakeRect({10, 10, 100, 50});
    SkRRect rrect2(rrect);
    rrect2.inset(20, 20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    std::string str("Type ");
    str += SkRRect::kEmpty_Type == rrect2.type() ? "=" : "!"; 
    str += "= SkRRect::kEmpty_Type";
    canvas->drawString(str.c_str(), 20, 80, SkPaint());
    canvas->drawRRect(rrect2, p);
##

#SeeAlso Type getType

#Method ##

#Subtopic Type ##

# ------------------------------------------------------------------------------

#Method inline bool isEmpty() const
#In Property
#Line # returns true if width or height are zero ##
Returns true if rect().fLeft is equal to rect().fRight, or if rect().fTop is equal
to rect().fBottom.

#Return true if width() or height() are zero ##

#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 10, 5);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isEmpty() ? "empty" : "not empty", 64, 90, paint);
    rrect.inset(40, 0);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isEmpty() ? "empty" : "not empty", 64, 90, paint);
##

#SeeAlso SkRect::isEmpty height width

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isRect() const
#In Property
#Line # returns true if not empty, and one radius at each corner is zero ##
Returns true if not empty, and if either x or y radius at each corner is zero.

#Return true if not empty, and one radius at each corner is zero ##

#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isRect() ? "rect" : "not rect", 64, 90, paint);
    SkVector radii[] = {{10, 10}, {0, 0}, {0, 0}, {0, 0}};
    rrect.setRectRadii(rrect.getBounds(), radii);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isRect() ? "rect" : "not rect", 64, 90, paint);
##

#SeeAlso isEmpty radii

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isOval() const
#In Property
#Line # returns true if not empty, axes radii are equal, radii fill bounds ##
Returns true if not empty, if all x-axis radii are equal, if all y-axis radii
are equal, x-axis radii are at least half the width, and y-axis radii are at
least half the height.

#Return true if has identical geometry to Oval ##

#Example
#Height 100
#Description
The first radii are scaled down proportionately until both x-axis and y-axis fit
within the bounds. After scaling, x-axis radius is smaller than half the width;
left round rect is not an oval. The second radii are equal to half the
dimensions; right round rect is an oval.
##
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 40, 30);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isOval() ? "oval" : "not oval", 64, 90, paint);
    rrect.setRectXY(rrect.getBounds(), 35, 25);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isOval() ? "oval" : "not oval", 64, 90, paint);
##

#SeeAlso isEmpty isSimple SkCanvas::drawOval

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isSimple() const
#In Property
#Line # returns true if not empty, rect or oval; and axes radii are equal ##
Returns true if not empty, if all x-axis radii are equal but not zero,
if all y-axis radii are equal but not zero; and x-axis radius is less than half
width(), or y-axis radius is less than half height().

#Return true if not empty, rect or oval; and axes radii are equal ##

#Bug 8107
#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkVector radii[] = {{40, 30}, {40, 30}, {40, 30}, {40, 30}};
    SkRRect rrect;
    rrect.setRectRadii({30, 10, 100, 60}, radii);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isSimple() ? "simple" : "not simple", 64, 90, paint);
    radii[0].fX = 35;
    rrect.setRectRadii(rrect.getBounds(), radii);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isSimple() ? "simple" : "not simple", 64, 90, paint);
##

#SeeAlso isEmpty isRect isOval isNinePatch

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isNinePatch() const
#In Property
#Line # returns true if not empty, rect, oval or simple; and radii are axis-aligned ##
Returns true if isEmpty, isRect, isOval, and isSimple return false; and if
left x-axis radii are equal, right x-axis radii are equal, top y-axis radii are
equal, and bottom y-axis radii are equal.

#Return true if not empty, rect, oval or simple; and radii are axis-aligned ##

#Bug 8107
#Example
#Height 100
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkVector radii[] = {{20, 30}, {40, 30}, {40, 30}, {20, 30}};
    SkRRect rrect;
    rrect.setRectRadii({30, 10, 100, 60}, radii);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isNinePatch() ? "9 patch" : "not 9 patch", 64, 90, paint);
    radii[0].fX = 35;
    rrect.setRectRadii(rrect.getBounds(), radii);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isNinePatch() ? "9 patch" : "not 9 patch", 64, 90, paint);
##

#SeeAlso isEmpty isRect isOval isSimple isComplex

#Method ##

# ------------------------------------------------------------------------------

#Method inline bool isComplex() const
#In Property
#Line # returns true if not empty, rect, oval, simple, or nine-patch ##

Returns true if isEmpty, isRect, isOval, isSimple, and isNinePatch return false.
If true: width and height are greater than zero, at least one corner radii are
both greater than zero; left x-axis radii are not equal, or right x-axis radii
are not equal, or top y-axis radii are not equal, or bottom y-axis radii are not
equal.

#Return true if not empty, rect, oval, simple, or nine-patch ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setTextAlign(SkPaint::kCenter_Align);
    paint.setTextSize(16);
    SkVector radii[] = {{25, 30}, {40, 30}, {40, 30}, {20, 30}};
    SkRRect rrect;
    rrect.setRectRadii({30, 10, 100, 60}, radii);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isComplex() ? "complex" : "not complex", 64, 90, paint);
    radii[0].fX = 20;
    rrect.setRectRadii(rrect.getBounds(), radii);
    canvas->translate(128, 0);
    canvas->drawRRect(rrect, paint);
    canvas->drawString(rrect.isComplex() ? "complex" : "not complex", 64, 90, paint);
##

#SeeAlso isEmpty isRect isOval isSimple isNinePatch

#Method ##

# ------------------------------------------------------------------------------

#Method SkScalar width() const
#In Property
#Line # returns span in x ##
Returns span on the x-axis. This does not check if result fits in 32-bit float;
result may be infinity.

#Return bounds().fRight minus bounds().fLeft ##

#Example
#Description
SkRRect::MakeRect sorts its input, so width() is always zero or larger.
##
    SkRRect unsorted = SkRRect::MakeRect({ 15, 25, 10, 5 });
    SkDebugf("unsorted width: %g\n", unsorted.width());
    SkRRect large = SkRRect::MakeRect({ -FLT_MAX, 1, FLT_MAX, 2 });
    SkDebugf("large width: %.0f\n", large.width());
#StdOut
unsorted width: 5
large width: inf
##
##

#SeeAlso SkRect::width height getBounds

#Method ##

# ------------------------------------------------------------------------------

#Method SkScalar height() const
#In Property
#Line # returns span in y ##
Returns span on the y-axis. This does not check if result fits in 32-bit float;
result may be infinity.

#Return bounds().fBottom minus bounds().fTop ##

#Example
#Description
SkRRect::MakeRect sorts its input, so height() is always zero or larger.
##
    SkRRect unsorted = SkRRect::MakeRect({ 15, 25, 10, 20 });
    SkDebugf("unsorted height: %g\n", unsorted.height());
    SkRRect large = SkRRect::MakeRect({ 1, -FLT_MAX, 2, FLT_MAX });
    SkDebugf("large height: %.0f\n", large.height());
#StdOut
unsorted height: 5
large height: inf
##
##

#SeeAlso SkRect.height width getBounds

#Method ##

# ------------------------------------------------------------------------------

#Method SkVector getSimpleRadii() const
#In Property
#Line # returns corner radii for simple types ##

Returns top-left corner x-radii. If type() returns kEmpty_Type, kRect_Type, 
kOval_Type, or kSimple_Type, returns a value representative of all corner radii.
If type() returns kNinePatch_Type or kComplex_Type, at least one of the
remaining three corners has a different value.

#Return corner radii for simple types ##

#Example
    auto drawDetails = [=](const SkRRect& rrect) {
        SkPaint paint;
        paint.setAntiAlias(true);
        paint.setTextAlign(SkPaint::kCenter_Align);
        paint.setTextSize(12);
        canvas->drawRRect(rrect, paint);
        SkVector corner = rrect.getSimpleRadii();
        std::string label = "corner: " + std::to_string(corner.fX).substr(0, 3) + ", " +
                        std::to_string(corner.fY).substr(0, 3);
        canvas->drawString(label.c_str(), 64, 90, paint);
        canvas->translate(128, 0);
    };
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    drawDetails(rrect);
    rrect.setRectXY(rrect.getBounds(), 5, 8);
    drawDetails(rrect);
##

#SeeAlso radii getBounds getType isSimple

#Method ##

# ------------------------------------------------------------------------------

#Method void setEmpty()
#In Set
#Line # zeroes width, height, and corner radii ##

Sets bounds to zero width and height at (0, 0), the origin. Sets
corner radii to zero and sets type to kEmpty_Type.

#Example
#Description
Nothing blue is drawn because rrect is set to empty.
##
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    rrect.setEmpty();
    paint.setColor(SK_ColorBLUE);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso MakeEmpty setRect

#Method ##

# ------------------------------------------------------------------------------

#Method void setRect(const SkRect& rect)
#In Set
#Line # sets rect bounds with zeroed corners ##

Sets bounds to sorted rect, and sets corner radii to zero.
If set bounds has width and height, and sets type to kRect_Type;
otherwise, sets type to kEmpty_Type.

#Param rect  bounds to set ##

#Example
#Height 90
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    rrect.setRect({60, 30, 120, 80});
    paint.setColor(SK_ColorBLUE);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso MakeRect setRectXY

#Method ##

# ------------------------------------------------------------------------------

#Method static SkRRect MakeEmpty()
#In Constructor
#Line # creates with zeroed bounds and corner radii ##

Initializes bounds at (0, 0), the origin, with zero width and height.
Initializes corner radii to (0, 0), and sets type of kEmpty_Type.

#Return empty Round_Rect ##

#Example
#Height 90
    SkRRect rrect = SkRRect::MakeEmpty();
    SkRRect rrect2(rrect);
    rrect2.inset(-20, -20);
    SkPaint p;
    p.setStyle(SkPaint::kStroke_Style);
    p.setStrokeWidth(10);
    std::string str("Type ");
    str += SkRRect::kEmpty_Type == rrect2.type() ? "=" : "!"; 
    str += "= SkRRect::kEmpty_Type";
    canvas->drawString(str.c_str(), 20, 80, SkPaint());
    canvas->drawRRect(rrect2, p);
##

#SeeAlso SkRRect() SkRect::MakeEmpty

#Method ##

# ------------------------------------------------------------------------------

#Method static SkRRect MakeRect(const SkRect& r)
#In Constructor
#Line # copies bounds and zeroes corner radii ##

Initializes to copy of r bounds and zeroes corner radii.

#Param r  bounds to copy ##

#Return copy of r ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRect({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    rrect.setOval(rrect.getBounds());
    paint.setColor(SK_ColorBLUE);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso setRect MakeOval MakeRectXY

#Method ##

# ------------------------------------------------------------------------------

#Method static SkRRect MakeOval(const SkRect& oval)
#In Constructor
#Line # creates Oval to fit bounds ##

Sets bounds to oval, x-axis radii to half oval.width(), and all y-axis radii
to half oval.height(). If rect is empty, sets to kEmpty_Type.
Otherwise, sets to kOval_Type.

#Param oval  bounds of Oval ##

#Return Oval ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeOval({30, 10, 100, 60});
    canvas->drawRRect(rrect, paint);
    rrect.setRect(rrect.getBounds());
    paint.setColor(SK_ColorBLUE);
    paint.setBlendMode(SkBlendMode::kDifference);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso setOval MakeRect MakeRectXY

#Method ##

# ------------------------------------------------------------------------------

#Method static SkRRect MakeRectXY(const SkRect& rect, SkScalar xRad, SkScalar yRad)
#In Constructor
#Line # creates rounded rectangle ##

Sets to rounded rectangle with the same radii for all four corners.
If rect is empty, sets to kEmpty_Type.
Otherwise, if xRad and yRad are zero, sets to kRect_Type.
Otherwise, if xRad is at least half rect.width() and yRad is at least half
rect.height(), sets to kOval_Type.
Otherwise, sets to kSimple_Type.

#Param rect  bounds of rounded rectangle ##
#Param xRad  x-axis radius of corners ##
#Param yRad  y-axis radius of corners ##

#Return rounded rectangle ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);
    canvas->drawRRect(rrect, paint);
    rrect.setRect(rrect.getBounds());
    paint.setColor(SK_ColorBLUE);
    paint.setBlendMode(SkBlendMode::kModulate);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso setRectXY

#Method ##

# ------------------------------------------------------------------------------

#Method void setOval(const SkRect& oval)
#In Set
#Line # replaces with Oval to fit bounds ##

Sets bounds to oval, x-axis radii to half oval.width(), and all y-axis radii
to half oval.height(). If rect is empty, sets to kEmpty_Type.
Otherwise, sets to kOval_Type.

#Param oval  bounds of Oval ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);
    canvas->drawRRect(rrect, paint);
    rrect.setOval(rrect.getBounds());
    paint.setColor(SK_ColorWHITE);
    paint.setBlendMode(SkBlendMode::kExclusion);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso MakeOval

#Method ##

# ------------------------------------------------------------------------------

#Method void setRectXY(const SkRect& rect, SkScalar xRad, SkScalar yRad)
#In Set
#Line # replaces with rounded rectangle ##

Sets to rounded rectangle with the same radii for all four corners.
If rect is empty, sets to kEmpty_Type.
Otherwise, if xRad or yRad is zero, sets to kRect_Type.
Otherwise, if xRad is at least half rect.width() and yRad is at least half
rect.height(), sets to kOval_Type.
Otherwise, sets to kSimple_Type.

#Param rect  bounds of rounded rectangle ##
#Param xRad  x-axis radius of corners ##
#Param yRad  y-axis radius of corners ##

#Example
#Height 70
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRectXY({30, 10, 100, 60}, 20, 20);
    canvas->drawRRect(rrect, paint);
    rrect.setRectXY(rrect.getBounds(), 5, 5);
    paint.setColor(SK_ColorWHITE);
    paint.setBlendMode(SkBlendMode::kExclusion);
    canvas->drawRRect(rrect, paint);
##

#SeeAlso MakeRectXY SkPath::addRoundRect

#Method ##

# ------------------------------------------------------------------------------

#Method void setNinePatch(const SkRect& rect, SkScalar leftRad, SkScalar topRad,
                      SkScalar rightRad, SkScalar bottomRad)
#In Set
#Line # replaces with rounded rectangle ##

Sets bounds to rect. Sets radii to (leftRad, topRad), (rightRad, topRad),
(rightRad, bottomRad), (leftRad, bottomRad).

If rect is empty, sets to kEmpty_Type.
Otherwise, if leftRad and rightRad are zero, sets to kRect_Type.
Otherwise, if topRad and bottomRad are zero, sets to kRect_Type.
Otherwise, if leftRad and rightRad are equal and at least half rect.width(), and
topRad and bottomRad are equal at least half rect.height(), sets to kOval_Type.
Otherwise, if leftRad and rightRad are equal, and topRad and bottomRad are equal,
sets to kSimple_Type. Otherwise, sets to kNinePatch_Type.

Nine patch refers to the nine parts defined by the radii: one center rectangle,
four edge patches, and four corner patches.

#Param rect  bounds of rounded rectangle ##
#Param leftRad  left-top and left-bottom x-axis radius ##
#Param topRad  left-top and right-top y-axis radius ##
#Param rightRad  right-top and right-bottom x-axis radius ##
#Param bottomRad  left-bottom and right-bottom y-axis radius ##

#Example
#Height 70
    SkPaint paint;
    paint.setAntiAlias(true);
    SkRRect rrect;
    rrect.setNinePatch({30, 10, 100, 60}, 10, 20, 20, 10);
    canvas->drawRRect(rrect, paint);
    paint.setColor(SK_ColorWHITE);
    const SkRect r = rrect.getBounds();
    canvas->drawLine(r.fLeft, r.fTop + rrect.radii(SkRRect::kUpperLeft_Corner).fY,
                     r.fRight, r.fTop + rrect.radii(SkRRect::kUpperRight_Corner).fY, paint);
    canvas->drawLine(r.fLeft, r.fBottom - rrect.radii(SkRRect::kLowerLeft_Corner).fY,
                     r.fRight, r.fBottom - rrect.radii(SkRRect::kLowerRight_Corner).fY, paint);
    canvas->drawLine(r.fLeft + rrect.radii(SkRRect::kUpperLeft_Corner).fX, r.fTop,
                     r.fLeft + rrect.radii(SkRRect::kLowerLeft_Corner).fX, r.fBottom, paint);
    canvas->drawLine(r.fRight - rrect.radii(SkRRect::kUpperRight_Corner).fX, r.fTop,
                     r.fRight - rrect.radii(SkRRect::kLowerRight_Corner).fX, r.fBottom, paint);
##

#SeeAlso setRectRadii

#Method ##

# ------------------------------------------------------------------------------

#Method void setRectRadii(const SkRect& rect, const SkVector radii[4])
#In Set
#Line # replaces with rounded rectangle ##

Sets bounds to rect. Sets radii array for individual control of all for corners.

If rect is empty, sets to kEmpty_Type.
Otherwise, if one of each corner radii are zero, sets to kRect_Type.
Otherwise, if all x-axis radii are equal and at least half rect.width(), and
all y-axis radii are equal at least half rect.height(), sets to kOval_Type.
Otherwise, if all x-axis radii are equal, and all y-axis radii are equal,
sets to kSimple_Type. Otherwise, sets to kNinePatch_Type.

#Param rect  bounds of rounded rectangle ##
#Param radii  corner x-axis and y-axis radii ##

#Example
    SkPaint paint;
    paint.setStrokeWidth(15);
    paint.setStrokeCap(SkPaint::kSquare_Cap);
    paint.setAntiAlias(true);
    float intervals[] = { 5, 21.75f };
    paint.setStyle(SkPaint::kStroke_Style);
    paint.setPathEffect(SkDashPathEffect::Make(intervals, SK_ARRAY_COUNT(intervals), 0));
    SkPath path;
    SkRRect rrect;
    SkVector corners[] = {{15, 17}, {17, 19}, {19, 15}, {15, 15}};
    rrect.setRectRadii({20, 20, 100, 100}, corners);
    path.addRRect(rrect, SkPath::kCW_Direction);
    canvas->drawPath(path, paint);
    path.rewind();
    path.addRRect(rrect, SkPath::kCCW_Direction, 1);
    canvas->translate(120, 0);
    canvas->drawPath(path, paint);
##

#SeeAlso setNinePatch SkPath::addRoundRect

#Method ##

# ------------------------------------------------------------------------------

#Enum Corner
#Line # corner radii order ##

#Code
    enum Corner {
        kUpperLeft_Corner,
        kUpperRight_Corner,
        kLowerRight_Corner,
        kLowerLeft_Corner,
    };
##

The radii are stored: top-left, top-right, bottom-right, bottom-left.

#Const kUpperLeft_Corner 0
#Line # index of top-left corner radii ##
##
#Const kUpperRight_Corner 1
#Line # index of top-right corner radii ##
##
#Const kLowerRight_Corner 2
#Line # index of bottom-right corner radii ##
##
#Const kLowerLeft_Corner 3
#Line # index of bottom-left corner radii ##
##

#Example
#Height 70
    SkPaint paint;
    paint.setAntiAlias(true);
    SkRRect rrect;
    SkVector corners[] = {{25, 17}, {17, 19}, {19, 15}, {15, 15}};
    rrect.setRectRadii({30, 10, 100, 60}, corners);
    canvas->drawRRect(rrect, paint);
    paint.setColor(SK_ColorWHITE);
    const SkRect r = rrect.getBounds();
    canvas->drawLine(r.fLeft, r.fTop + rrect.radii(SkRRect::kUpperLeft_Corner).fY,
                     r.fRight, r.fTop + rrect.radii(SkRRect::kUpperRight_Corner).fY, paint);
    canvas->drawLine(r.fLeft, r.fBottom - rrect.radii(SkRRect::kLowerLeft_Corner).fY,
                     r.fRight, r.fBottom - rrect.radii(SkRRect::kLowerRight_Corner).fY, paint);
    canvas->drawLine(r.fLeft + rrect.radii(SkRRect::kUpperLeft_Corner).fX, r.fTop,
                     r.fLeft + rrect.radii(SkRRect::kLowerLeft_Corner).fX, r.fBottom, paint);
    canvas->drawLine(r.fRight - rrect.radii(SkRRect::kUpperRight_Corner).fX, r.fTop,
                     r.fRight - rrect.radii(SkRRect::kLowerRight_Corner).fX, r.fBottom, paint);
##

#SeeAlso radii

#Enum ##

# ------------------------------------------------------------------------------

#Method const SkRect& rect() const
#In Property
#Line # returns bounds ##
Returns bounds. Bounds may have zero width or zero height. Bounds right is
greater than or equal to left; bounds bottom is greater than or equal to top.
Result is identical to getBounds.

#Return bounding box ##

#Example
    for (SkScalar left : { SK_ScalarNaN, SK_ScalarInfinity, 100.f, 50.f, 25.f} ) {
        SkRRect rrect1 = SkRRect::MakeRectXY({left, 20, 60, 220}, 50, 200);
        SkDebugf("left bounds: (%g) %g\n", left, rrect1.rect().fLeft);
    }
#StdOut
left bounds: (nan) 0
left bounds: (inf) 0
left bounds: (100) 60
left bounds: (50) 50
left bounds: (25) 25
##
##

#SeeAlso getBounds

#Method ##

# ------------------------------------------------------------------------------

#Method SkVector radii(Corner corner) const
#In Property
#Line # returns x-axis and y-axis radii for one corner ##
Returns Scalar pair for radius of curve on x-axis and y-axis for one corner.
Both radii may be zero. If not zero, both are positive and finite.


#Param corner  one of: kUpperLeft_Corner, kUpperRight_Corner,
                       kLowerRight_Corner, kLowerLeft_Corner 
##

#Return x-axis and y-axis radii for one corner ##

#Example
#Description
Finite values are scaled proportionately to fit; other values are set to zero.
Scaled values cannot be larger than 25, half the bounding rect width.
Small scaled values are halved to scale in proportion to the y-axis corner
radius, which is twice the bounds height.
##
    for (SkScalar radiusX : { SK_ScalarNaN, SK_ScalarInfinity, 100.f, 50.f, 25.f} ) {
        SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, radiusX, 200);
        SkDebugf("left corner: (%g) %g\n", radiusX, rrect1.radii(SkRRect::kUpperLeft_Corner).fX);
    }
#StdOut
left corner: (nan) 0
left corner: (inf) 0
left corner: (100) 25
left corner: (50) 25
left corner: (25) 12.5
##
##

#SeeAlso Corner

#Method ##

# ------------------------------------------------------------------------------

#Method const SkRect& getBounds() const
#In Property
#Line # returns bounds ##
Returns bounds. Bounds may have zero width or zero height. Bounds right is
greater than or equal to left; bounds bottom is greater than or equal to top.
Result is identical to rect().

#Return bounding box ##

#Example
#Height 120
    SkPaint paint;
    SkRRect rrect = SkRRect::MakeRectXY({20, 20, 220, 100}, 15, 15);
    canvas->drawRRect(rrect, paint);
    paint.setColor(SK_ColorWHITE);
    rrect = SkRRect::MakeOval(rrect.getBounds());
    canvas->drawRRect(rrect, paint);
##

#SeeAlso rect

#Method ##

# ------------------------------------------------------------------------------

#Method bool operator==(const SkRRect& a, const SkRRect& b)
#In Operator
#Line # returns true if members are equal ##
Returns true if bounds and radii in a are equal to bounds and radii in b.

a and b are not equal if either contain NaN. a and b are equal if members
contain zeroes width different signs.

#Param a  Rect bounds and radii to compare ##
#Param b  Rect bounds and radii to compare ##

#Return true if members are equal ##

#Example
    SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, 50, 200);
    SkRRect rrect2 = SkRRect::MakeRectXY(rrect1.rect(), 25, 100);
    SkRRect rrect3 = SkRRect::MakeOval(rrect1.rect());
    canvas->drawRRect(rrect1, SkPaint());
    std::string str = "rrect1 " + std::string(rrect1 == rrect2 ? "=" : "!") + "= rrect2";
    canvas->drawString(str.c_str(), 10, 240, SkPaint());
    canvas->translate(70, 0);
    canvas->drawRRect(rrect2, SkPaint());
    canvas->translate(70, 0);
    canvas->drawRRect(rrect3, SkPaint());
    str = "rrect2 " + std::string(rrect2 == rrect3 ? "=" : "!") + "= rrect3";
    canvas->drawString(str.c_str(), -20, 240, SkPaint());
##

#SeeAlso operator!=(const SkRRect& a, const SkRRect& b)

#Method ##

# ------------------------------------------------------------------------------

#Method bool operator!=(const SkRRect& a, const SkRRect& b)
#In Operator
#Line # returns true if members are unequal ##
Returns true if bounds and radii in a are not equal to bounds and radii in b.

a and b are not equal if either contain NaN. a and b are equal if members
contain zeroes width different signs.

#Param a  Rect bounds and radii to compare ##
#Param b  Rect bounds and radii to compare ##

#Return true if members are not equal ##

#Example
    SkRRect rrect1 = SkRRect::MakeRectXY({10, 20, 60, 220}, 50, 100);
    SkRRect rrect2 = SkRRect::MakeRectXY(rrect1.rect(), 50, 50);
    SkRRect rrect3 = SkRRect::MakeOval(rrect1.rect());
    canvas->drawRRect(rrect1, SkPaint());
    std::string str = "rrect1 " + std::string(rrect1 == rrect2 ? "=" : "!") + "= rrect2";
    canvas->drawString(str.c_str(), 10, 240, SkPaint());
    canvas->translate(70, 0);
    canvas->drawRRect(rrect2, SkPaint());
    canvas->translate(70, 0);
    canvas->drawRRect(rrect3, SkPaint());
    str = "rrect2 " + std::string(rrect2 == rrect3 ? "=" : "!") + "= rrect3";
    canvas->drawString(str.c_str(), -20, 240, SkPaint());
##

#SeeAlso operator==(const SkRRect& a, const SkRRect& b)

#Method ##

# ------------------------------------------------------------------------------

#Method void inset(SkScalar dx, SkScalar dy, SkRRect* dst) const
#In Inset_Outset_Offset
#Line # insets bounds and radii ##

Calls inset on the bounds, and adjust the radii to reflect what happens.
If the corner is sharp (no curvature), leave it alone,
otherwise we grow/shrink the radii by the amount of the inset. If a
given radius becomes negative, it is pinned to 0.
If the inset amount is larger than the width/height then the rrect collapses to
a degenerate line or point.
If the inset is sufficiently negative to cause the bounds to become infinite then
the result is a default initialized rrect.
It is valid for dst == this.

#Param dx  added to rect().fLeft, and subtracted from rect().fRight ##
#Param dy  added to rect().fTop, and subtracted from rect().fBottom ##
#Param dst  insets bounds and radii ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.inset(-3, 3, &rrect);
    }
##

#SeeAlso outset offset makeOffset

#Method ##

# ------------------------------------------------------------------------------

#Method void inset(SkScalar dx, SkScalar dy)
#In Inset_Outset_Offset
#Line # insets bounds and radii ##

#Param dx  added to rect().fLeft, and subtracted from rect().fRight ##
#Param dy  added to rect().fTop, and subtracted from rect().fBottom ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({10, 20, 180, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.inset(3, 3);
    }
##

#SeeAlso outset offset makeOffset


#Method ##

# ------------------------------------------------------------------------------

#Method void outset(SkScalar dx, SkScalar dy, SkRRect* dst) const
#In Inset_Outset_Offset
#Line # outsets bounds and radii ##

Call outset on the bounds, and adjust the radii to reflect what happens
in stroking. If the corner is sharp (no curvature), leave it alone,
otherwise we grow/shrink the radii by the amount of the inset. If a
given radius becomes negative, it is pinned to 0.
It is valid for dst == this.

#Param dx  subtracted from rect().fLeft, and added to rect().fRight ##
#Param dy  subtracted from rect().fTop, and added to rect().fBottom ##
#Param dst  outset bounds and radii ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.outset(-3, 3, &rrect);
    }
##

#SeeAlso inset offset makeOffset


#Method ##

# ------------------------------------------------------------------------------

#Method void outset(SkScalar dx, SkScalar dy)
#In Inset_Outset_Offset
#Line # outsets bounds and radii ##

#Param dx  subtracted from rect().fLeft, and added to rect().fRight ##
#Param dy  subtracted from rect().fTop, and added to rect().fBottom ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.outset(3, 3);
    }
##

#SeeAlso inset offset makeOffset

#Method ##

# ------------------------------------------------------------------------------

#Method void offset(SkScalar dx, SkScalar dy)
#In Inset_Outset_Offset
#Line # offsets bounds and radii ##

Translates the rrect by (dx, dy).

#Param dx  offset added to rect().fLeft and rect().fRight ##
#Param dy  offset added to rect().fTop and rect().fBottom ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect.offset(3, 3);
    }
##

#SeeAlso makeOffset inset outset

#Method ##

# ------------------------------------------------------------------------------

#Method SkRRect SK_WARN_UNUSED_RESULT makeOffset(SkScalar dx, SkScalar dy) const
#In Inset_Outset_Offset
#Line # offsets bounds and radii ##

#Param dx  offset added to rect().fLeft and rect().fRight ##
#Param dy  offset added to rect().fTop and rect().fBottom ##

#Return Round_Rect bounds offset by (dx, dy), with unchanged corner radii ##

#Example
    SkPaint paint;
    paint.setAntiAlias(true);
    paint.setStyle(SkPaint::kStroke_Style);
    SkRRect rrect = SkRRect::MakeRectXY({100, 20, 140, 220}, 50, 100);
    for (int index = 0; index < 25; ++index) {
       canvas->drawRRect(rrect, paint);
       rrect = rrect.makeOffset(-3, 3);
    }
##

#SeeAlso offset inset outset

#Method ##

# ------------------------------------------------------------------------------

#Method bool contains(const SkRect& rect) const
#In Intersection
#Line # returns true if Rect is inside ##

Returns true if rect is inside the bounds and corner radii, and if
Round_Rect and rect are not empty.

#Param rect  area tested for containment ##

#Return true if Round_Rect contains rect ##

#Example
// incomplete
##

#SeeAlso SkRect::contains

#Method ##

# ------------------------------------------------------------------------------

#Method bool isValid() const
#In Utility
#Line # incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Const kSizeInMemory 48
#Line # incomplete ##

#Example
// incomplete
##

#Const ##

# ------------------------------------------------------------------------------

#Method size_t writeToMemory(void* buffer) const
#In Utility
#Line # incomplete ##

Write the rrect into the specified buffer. This is guaranteed to always
write kSizeInMemory bytes, and that value is guaranteed to always be
a multiple of 4. Return kSizeInMemory.

#Param buffer  incomplete ##

#Return incomplete ##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method size_t readFromMemory(const void* buffer, size_t length)
#In Utility
#Line # incomplete ##

Reads the rrect from the specified buffer.
If the specified buffer is large enough, this will read kSizeInMemory bytes,
and that value is guaranteed to always be a multiple of 4.

#Param buffer  memory to read from
##
#Param length  amount of memory available in the buffer
##

#Return  number of bytes read (must be a multiple of 4) or
        0 if there was not enough memory available
##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method bool transform(const SkMatrix& matrix, SkRRect* dst) const
#In Inset_Outset_Offset
#Line # scales and offsets into copy ##

Transforms by Round_Rect by matrix, storing result in dst.
Returns true if Round_Rect transformed can be represented by another Round_Rect.
Returns false if matrix contains transformations other than scale and translate.

Asserts in debug builds if Round_Rect equals dst.

#Param matrix  SkMatrix specifying the transform ##
#Param dst  SkRRect to store the result ##

#Return  true if transformation succeeded.
##

#Example
// incomplete
##

#SeeAlso incomplete

#Method ##

# ------------------------------------------------------------------------------

#Method void dump(bool asHex) const
#In Utility
#Line # sends text representation to standard output ##
Writes text representation of Round_Rect to standard output.
Set asHex true to generate exact binary representations
of floating point numbers.

#Param asHex  true if SkScalar values are written as hexadecimal ##

#Example
SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});
for (bool dumpAsHex : { false, true } ) {
    rrect.dump(dumpAsHex);
}
#StdOut
SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);
const SkPoint corners[] = {
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
};
SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab)  /* 0.666667 */);
const SkPoint corners[] = {
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
};
##
##

#SeeAlso dumpHex SkRect::dump SkPath::dump SkPathMeasure::dump

#Method ##

# ------------------------------------------------------------------------------

#Method void dump() const
#In Utility
#Line # sends text representation using floats to standard output ##
Writes text representation of Round_Rect to standard output. The representation
may be directly compiled as C++ code. Floating point values are written
with limited precision; it may not be possible to reconstruct original
Round_Rect from output.

#Example
SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});
rrect.dump();
SkRect bounds = SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);
const SkPoint corners[] = {
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
};
SkRRect copy;
copy.setRectRadii(bounds, corners);
SkDebugf("rrect is " "%s" "equal to copy\n", rrect == copy ? "" : "not ");
#StdOut
SkRect::MakeLTRB(0.857143f, 0.666667f, 0.857143f, 0.666667f);
const SkPoint corners[] = {
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
    { 0, 0 },
};
rrect is not equal to copy
##
##

#SeeAlso dumpHex SkRect::dump SkPath::dump SkPathMeasure::dump

#Method ##

# ------------------------------------------------------------------------------

#Method void dumpHex() const
#In Utility
#Line # sends text representation using hexadecimal to standard output ##
Writes text representation of Round_Rect to standard output. The representation
may be directly compiled as C++ code. Floating point values are written
in hexadecimal to preserve their exact bit pattern. The output reconstructs the
original Round_Rect.

#Example
SkRRect rrect = SkRRect::MakeRect({6.f / 7, 2.f / 3, 6.f / 7, 2.f / 3});
rrect.dumpHex();
SkRect bounds = SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab)  /* 0.666667 */);
const SkPoint corners[] = {
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
};
SkRRect copy;
copy.setRectRadii(bounds, corners);
SkDebugf("rrect is " "%s" "equal to copy\n", rrect == copy ? "" : "not ");
#StdOut
SkRect::MakeLTRB(SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab), /* 0.666667 */
                 SkBits2Float(0x3f5b6db7), /* 0.857143 */
                 SkBits2Float(0x3f2aaaab)  /* 0.666667 */);
const SkPoint corners[] = {
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
    { SkBits2Float(0x00000000), SkBits2Float(0x00000000) }, /* 0.000000 0.000000 */
};
rrect is equal to copy
##
##

#SeeAlso dump SkRect::dumpHex SkPath::dumpHex

#Method ##

#Class SkRRect ##

#Topic RRect ##
